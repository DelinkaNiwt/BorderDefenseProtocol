---
标题：RimWorld游戏系统笔记
版本号: v10.0
更新日期: 2026-02-16
最后修改者: Claude Opus 4.6
标签：[文档][用户未确认][未完成][未锁定]
摘要: 记录用户对RimWorld现有游戏系统的理解笔记（摘要+索引），详细内容见各📖参考文档。已完成第1-6、8章笔记（第6章全部10节、第8章全部6节完成）+ 第9章全部5节完成 + 第7章第1/2/3/4/5节完成 + 第10章全部5节完成 + 第11章全部5节完成 + 第12章第1/2/3/4节完成 + 第13章全部4节完成，覆盖2.6全部15个游戏实体和14条需实现关系。
---

## 前置说明

**本文档是什么**：你（用户）对RimWorld游戏系统的个人理解笔记。理解多少写多少，不需要面面俱到。

**本文档不是什么**：
- 不是RimWorld Wiki搬运——只记你理解的部分
- 不是代码分析——代码层面的技术框架记录在4.2中
- 不是模组设计——模组的技术选型在4.3/4.4中

**4.1与4.2的边界**：
- **4.1（本文档）**：游戏系统层面——"RimWorld里XX系统是怎么玩的、有什么规则"
- **4.2**：技术框架层面——"RimWorld用什么Def/Comp/Worker来实现这些系统"

**如何使用**：每章包含引导问题，帮助你回忆和组织思路。直接在问题下方写答案即可。

**优先级说明**：★★★ = 直接影响核心系统选型，建议优先填写；★☆☆ = 可后续补充

---

## 目录

- [第1章 Pawn与健康系统 ★★★](#第1章-pawn与健康系统-)
- [第2章 需求与资源系统 ★★★](#第2章-需求与资源系统-)
- [第3章 基因系统 ★★★](#第3章-基因系统-)
- [第4章 装备与物品系统 ★★★](#第4章-装备与物品系统-)
- [第5章 能力与特性系统 ★★☆](#第5章-能力与特性系统-)
- [第6章 战斗系统 ★★★](#第6章-战斗系统-)
- [第7章 派系系统 ★★☆](#第7章-派系系统-)
- [第8章 事件与袭击系统 ★★☆](#第8章-事件与袭击系统-)
- [第9章 机械体与人工单位 ★★☆](#第9章-机械体与人工单位-)
- [第10章 建筑与工作台 ★☆☆](#第10章-建筑与工作台-)
- [第11章 传送、远行与世界地图 ★☆☆](#第11章-传送远行与世界地图-)
- [第12章 视觉与渲染 ★☆☆](#第12章-视觉与渲染-)
- [第13章 科研系统 ★☆☆](#第13章-科研系统-)
- [附录A DLC系统速查](#附录a-dlc系统速查)
- [附录B 模组需求→章节映射](#附录b-模组需求章节映射)

---

## 第1章 Pawn与健康系统 ★★★

> **对应模组需求**：战斗体状态切换、伤害隔离（R16）、弱点系统、Trion接收器植入体（实体2）

### 引导问题

1. Pawn身上的Hediff（健康状况）有哪些大类？你能举几个例子吗？（如：疾病、受伤、植入体、慢性病……）
2. 植入体（Implant）装上后，游戏里怎么体现效果的？你见过哪些植入体的效果？
3. Hediff有"严重程度"（Severity）的概念，你理解它是怎么变化的？（自然恢复、恶化、治疗……）
4. 你理解的"身体部位"系统是什么样的？伤害怎么分配到具体部位？
5. 一个Pawn死亡的判定条件是什么？你知道哪些致死方式？
6. 你见过Hediff之间互相影响的情况吗？（比如某个状态触发另一个状态）

### 你的笔记

#### 1. Hediff大类整理

Hediff（Health Difference）是RimWorld中附加在Pawn身上的一切健康状态的统称。按功能分8大类：

| # | 功能分类 | C#类 | 典型实例 | DLC |
|---|---------|------|---------|-----|
| 1 | **物理伤害** | `Hediff_Injury` | 切割伤、瘀伤、烧伤、枪伤 | Core |
| 2 | **缺失部位** | `Hediff_MissingPart` | 失去左臂、失去左眼 | Core |
| 3 | **植入体/假肢** | `Hediff_Implant` → `Hediff_AddedPart` | 仿生眼、义肢、心灵连接器 | Core |
| 4 | **疾病/状态** | `HediffWithComps` | 流感、瘟疫、哮喘、白内障 | Core |
| 5 | **药物相关** | `Hediff_High` / `Hediff_Addiction` | 烟瘾、酒精兴奋、宿醉 | Core |
| 6 | **生育相关** | `Hediff_Pregnant` / `Hediff_Labor` | 怀孕、分娩 | Biotech |
| 7 | **基因/机械相关** | `Hediff_Deathrest` 等 | 死眠、化学依赖、频段连接 | Biotech |
| 8 | **异常相关** | `Hediff_Shambler` 等 | 蹒跚者转化、金属恐怖寄生 | Anomaly |

> **要点**：绝大多数Buff/Debuff直接使用`HediffWithComps`+XML配置`HediffComp`组件，只有需要特殊逻辑才需要自定义Hediff子类。

📖 [Hediff分类与继承体系](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Hediff分类与继承体系.md)

#### 2. 植入体效果机制

植入体分两大类：**替换型**（`Hediff_AddedPart`，替换身体部位并设定效率）和**附加型**（`Hediff_Implant`，附加在部位上通过stages/comps提供效果）。

| 维度 | 替换型（AddedPart） | 附加型（Implant） |
|------|---------------------|-------------------|
| 核心行为 | 恢复部位，设定`partEfficiency` | 标记性基类，无特殊逻辑 |
| 效果来源 | `addedPartProps.partEfficiency` | `stages`属性修改器 + `comps`组件 |
| 典型实例 | 义肢臂、仿生眼 | 心灵连接器、止痛器 |

> **要点**：
> 1. 大多数植入体效果只需XML中的`stages`字段，无需写C#
> 2. 一个植入体可同时使用Stage + Comp + Def字段，三层效果互不冲突

📖 [植入体效果机制](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\植入体效果机制.md)

#### 3. Severity严重程度机制

Severity是Hediff的核心数值轴——驱动阶段切换、效果强度变化、自动移除（≤0）和致死判定（≥lethalSeverity）。7种变化机制：

| # | 机制 | 类型 | 典型实例 |
|---|------|------|---------|
| 1 | **SeverityPerDay** | HediffComp | GoJuiceHigh: -0.75/天 |
| 2 | **Immunizable** | HediffComp | Flu: 未免疫恶化，免疫后康复 |
| 3 | **TendDuration** | HediffComp | Flu: 治疗加速康复 |
| 4 | **GrowthMode** | HediffComp | Carcinoma: 癌症生长/稳定/缓解 |
| 5 | **SelfHeal** | HediffComp | 伤口自愈 |
| 6 | **Disappears** | HediffComp | 不修改Severity，直接移除 |
| 7 | **外部系统直接控制** | 非Comp | Hypothermia: 温度系统直接写入 |

> **要点**：
> 1. 同一Hediff可叠加多个Severity变化Comp，每Tick各自贡献后一次性累加
> 2. 自定义Hediff优先使用现有Comp（SeverityPerDay最常用），不够再自定义

📖 [Severity严重程度机制](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Severity严重程度机制.md)

#### 4. 身体部位与伤害分配系统

身体系统是以Torso为根的树形结构，每个部位通过三维坐标定位：

| 维度 | 值 | 说明 |
|------|-----|------|
| **Height** | Top / Middle / Bottom | 垂直高度 |
| **Depth** | Outside / Inside | 深度层级 |
| **Coverage** | 0~1 | 在父部位中的覆盖占比，决定被命中概率 |

伤害分配核心：按`coverageAbs × hitChanceFactor`加权随机命中部位，再由DamageWorker决定传播方式。5种DamageWorker：

| DamageWorker | ChooseHitPart | 特殊行为 |
|-------------|---------------|---------|
| **Blunt** | 强制Outside | 概率穿透到骨骼 + 眩晕 |
| **Cut** | 强制Outside | 向外传播 + 劈砍分裂 |
| **Scratch** | 强制Outside | 分裂到相邻部位 |
| **Stab** | 可穿透Inside | 概率直接命中内部 |

> **要点**：
> 1. 模组新增身体部位时，子部位coverage之和不应超过1.0
> 2. Inside部位有天然保护——只有Stab有概率直接命中

📖 [身体部位与伤害分配系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\身体部位与伤害分配系统.md)

#### 5. Pawn死亡判定与致死方式

`ShouldBeDead()`的5个判定条件（短路求值）：

| # | 条件 | 说明 |
|---|------|------|
| 1 | **死亡豁免** | 有`preventsDeath=true`的Hediff → 跳过所有判定 |
| 2 | **Hediff致死严重度** | `Severity ≥ lethalSeverity` |
| 3 | **致命能力降为0** | 肉体5种/机械体3种致命能力 |
| 4 | **核心部位效率为0** | Torso被摧毁 |
| 5 | **累计伤害超阈值** | `Σ Injury.Severity ≥ 150 × HealthScale` |

其他致死路径：`deathMtbDays`随机死亡、倒地即死（非玩家阵营）、疼痛休克→倒地→概率死亡。

> **要点**：
> 1. 死亡判定是被动触发的——直接修改Severity而不通过标准API可能不触发
> 2. 累计伤害阈值与HealthScale成正比——大型生物更难被"磨死"

📖 [Pawn死亡判定与致死方式](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Pawn死亡判定与致死方式.md)

#### 6. Hediff互相影响与触发机制

5大类机制：

| # | 机制类别 | 触发方式 | 典型场景 |
|---|---------|---------|---------|
| 1 | **HediffGiver系统** | 每60 ticks检查 | 出血→失血、年龄→慢性病 |
| 2 | **HediffComp交互** | 每200 ticks检查 | 并发症触发、Hediff互斥 |
| 3 | **生命周期回调** | Hediff添加/移除时 | 植入体恢复部位 |
| 4 | **Stage层级触发** | 进入特定阶段时 | 阶段性并发症 |
| 5 | **典型交互模式** | 上述组合 | 8种常见模式 |

8种典型交互模式：出血→失血、疾病→免疫竞赛、年龄→慢性病、环境→体温异常、疾病→并发症、器官衰竭→死亡、范围光环、Hediff互斥。

> **要点**：
> 1. 外部条件触发用HediffGiver，自身状态触发用HediffComp
> 2. `GiveHediff`/`ReplaceHediff`/`RemoveIfOtherHediff`覆盖最常见场景，无需写C#

📖 [Hediff互相影响与触发机制](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Hediff互相影响与触发机制.md)

---

## 第2章 需求与资源系统 ★★★

> **对应模组需求**：Trion能量技术选型（实体：Trion）、R1腺体产生Trion、R12触发体消耗Trion、R34远征船消耗Trion、D5资源池博弈

### 引导问题

1. 原版有哪些Need（需求）？你能列举几个吗？（心情、食物、休息、娱乐……）
2. Need的数值是怎么变化的？（持续下降？事件触发？有上限吗？）
3. Need降到0或升到满会发生什么？你见过哪些极端情况？
4. 你知道模组新增的Need吗？（比如VE系列或其他模组）它们的表现和原版一样吗？
5. 除了Need，还有没有其他"资源条"类的系统？（比如机械师的带宽、基因的代谢效率……）

### 你的笔记

#### 1. Need（需求）系统总览

Need是Pawn的内在状态条，每150 ticks更新一次。18个子类分两大模式：**普通Need**（持续下降，需行为补充）和**Seeker Need**（追踪环境瞬时值并趋近）。

| Need | C#类 | DLC | 模式 |
|------|------|-----|------|
| 心情 | `Need_Mood` | Core | Seeker |
| 美观 | `Need_Beauty` | Core | Seeker |
| 舒适 | `Need_Comfort` | Core | Seeker |
| 房间大小 | `Need_RoomSize` | Core | Seeker |
| 饥饿 | `Need_Food` | Core | 下降 |
| 休息 | `Need_Rest` | Core | 下降 |
| 娱乐 | `Need_Joy` | Core | 下降 |
| 户外 | `Need_Outdoors` | Core | 下降 |
| 室内 | `Need_Indoors` | Core | 下降 |
| 化学品 | `Need_Chemical` | Core | 下降 |
| 化学品渴望 | `Need_Chemical_Any` | Core | 下降 |
| 机械能量 | `Need_MechEnergy` | Biotech | 下降 |
| 死亡休息 | `Need_Deathrest` | Biotech | 下降 |
| 学习 | `Need_Learning` | Biotech | 下降 |
| 玩耍 | `Need_Play` | Biotech | 下降 |
| 杀戮渴望 | `Need_KillThirst` | Biotech | 下降 |
| 权威 | `Need_Authority` | Royalty | 下降 |
| 压制 | `Need_Suppression` | Ideology | 下降 |

> **要点**：
> 1. 模组新增Need只需定义NeedDef + C#类，条件激活通过NeedDef字段控制

📖 [Need需求系统总览](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Need需求系统总览.md)

#### 2. Need数值变化机制

4种变化模式：

| # | 模式 | 机制 | 代表Need |
|---|------|------|---------|
| 1 | **持续下降型** | NeedInterval中按速率下降，需行为补充 | Food, Rest, Joy |
| 2 | **Seeker趋近型** | 追踪瞬时环境值，逐渐趋近 | Mood, Beauty, Comfort |
| 3 | **条件下降型** | 仅特定条件下下降 | Outdoors, MechEnergy |
| 4 | **外部驱动型** | 主要由外部系统直接修改 | Suppression |

> **要点**：
> 1. 持续下降型是最常见的模组参考模式——NeedInterval中下降，特定行为补充
> 2. Stat修饰符（如`RestFallRateFactor`）可让基因/植入体/装备影响Need变化速率，无需修改Need代码

📖 [Need需求系统总览](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Need需求系统总览.md)

#### 3. Need极端值效果

| Need | 极端低值效果 | 致命性 |
|------|------------|--------|
| **Food=0** | 营养不良→约2.2天致死 | ⚠️ 直接致死 |
| **Mood过低** | 精神崩溃（3级，含自杀/杀人） | ⚠️ 间接致死 |
| **Suppression=0** | 奴隶叛乱（3种规模） | ⚠️ 高危险 |
| **Rest=0** | 非自愿睡眠（MTB递增） | 低风险 |
| **MechEnergy=0** | 自动关机（以1/天恢复） | 不致死 |

精神崩溃系统：心情低于阈值持续≥2000 ticks后按MTB概率触发，恢复后15000 ticks冷却。三级：Minor(MTB 4天) → Major(MTB 0.8天) → Extreme(MTB 0.5天)。

> **要点**：
> 1. 致死Need设计模式：Food通过Need→Hediff→lethalSeverity链条致死，而非Need直接杀死Pawn
> 2. MechEnergy的自动关机是"软惩罚"设计典范——关机期间缓慢恢复，恢复至15时自动解除

📖 [Need极端值效果与精神崩溃系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Need极端值效果与精神崩溃系统.md)

#### 4. 模组自定义Need与资源追踪方案对比

社区模组极少创建自定义Need。已知实例：Dubs Bad Hygiene（Hygiene/Bladder）、RimWorld of Magic（Mana）。

4种资源追踪方案对比：

| 维度 | Need | Gene_Resource | Hediff | Harmony补丁 |
|------|------|--------------|--------|------------|
| **UI位置** | Need面板 | Gizmo栏 | 健康面板/自定义 | 修改原版UI |
| **值范围** | 0~MaxLevel | 0~max | 0~maxSeverity | 同原版 |
| **Stage效果** | 无 | 无 | 有（多阶段） | 同原版 |
| **DLC依赖** | Core | Biotech | Core | Core |

📖 [Need需求系统总览](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Need需求系统总览.md)

#### 5. 原版非Need资源条系统

除Need外，原版还有5个独立"类资源条"系统：

| # | 系统 | DLC | 实现类 | 值范围 |
|---|------|-----|--------|--------|
| 1 | **Psyfocus** | Royalty | `Pawn_PsychicEntropyTracker` | 0~1，3个Band分段衰减 |
| 2 | **Neural Heat** | Royalty | 同上（共用Tracker） | 0~Max，可超限至2× |
| 3 | **Bandwidth** | Biotech | `Pawn_MechanitorTracker` | 离散整数，容量/占用模型 |
| 4 | **Hemogen** | Biotech | `Gene_Hemogen` | 0~max，IGeneResourceDrain |
| 5 | **Gauranlen Connection** | Ideology | `CompTreeConnection` | 0~1，附加在Thing上 |

4种架构模式：Tracker（复杂多值联动）、Gene_Resource（基因绑定资源）、ThingComp（非Pawn实体）、Need（简单Pawn资源）。

> **要点**：
> 1. Tracker模式最灵活但成本最高——需自定义Tracker类+Gizmo类+完整值管理

---

## 第3章 基因系统 ★★★

> **对应模组需求**：Trion腺体（实体1）、R1腺体产生Trion、R5 Trion触发副作用

### 引导问题

1. 基因系统的基本结构是什么？（异种基因vs内源基因、基因组、基因包……）
2. 基因能提供哪些类型的效果？你能分几大类吗？（属性修改、能力赋予、外观改变……）
3. 代谢效率是什么？基因怎么影响它？这对殖民者有什么实际影响？
4. 基因怎么获得和移除？你知道几种途径？
5. 你见过模组自定义的基因吗？它们和原版基因的表现有什么不同？

### 你的笔记

#### 1. 基因系统基本结构

三层架构：`GeneDef`（定义层，80+字段）→ `Gene`（实例层）→ `Pawn_GeneTracker`（管理层，双列表）。

| 维度 | Xenogene（异种基因） | Endogene（内源基因） |
|------|---------------------|---------------------|
| 来源 | Xenogerm植入、基因组装器 | 出生继承、种族默认 |
| 可遗传 | 否（除非inheritable=true） | 是 |
| 覆盖规则 | 优先覆盖同exclusionTag的Endogene | 被Xenogene覆盖时Active=false |
| 移除方式 | 新Xenogerm植入时全部清除 | 通常不可移除 |

> **要点**：
> 1. 绝大多数基因不需要自定义Gene子类——GeneDef的80+字段覆盖大多数效果
> 2. Gene_Resource是资源型基因的标准模式——内置cur/max/targetValue + GeneGizmo_Resource UI

📖 [基因系统结构与继承体系](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\基因系统结构与继承体系.md)

#### 2. 基因效果分类

16种效果类型，通过两条路径实现：**GeneDef字段配置**（大多数，纯XML）和**Gene子类行为**（少数需运行时逻辑）。

| # | 效果类型 | 实现方式 | 典型实例 |
|---|---------|---------|---------|
| 1 | 属性修改 | GeneDef | 移动速度+20% |
| 2 | 能力赋予 | GeneDef | 吸血、毒液攻击 |
| 3 | 能力修改 | GeneDef | 视力+50% |
| 4 | 特质控制 | GeneDef | 强制嗜血 |
| 5 | Need控制 | GeneDef | 启用杀戮渴望 |
| 6 | 外观改变 | GeneDef | 皮肤颜色、毛皮 |
| 7 | 免疫/抗性 | GeneDef | 免疫毒气 |
| 8 | 疼痛修改 | GeneDef | 疼痛×0.5 |
| 9-12 | 药物/行为/技能/社交 | GeneDef | 成瘾概率×0、禁止暴力 |
| 13-14 | 资源追踪/特殊行为 | Gene子类 | Hemogen、死眠 |
| 15-16 | 代谢/遗传控制 | GeneDef | 复杂度+2、互斥标签 |

> **要点**：
> 1. `statOffsets`（加值）vs `statFactors`（倍率）独立计算
> 2. `conditionalStatAffecters`实现条件效果（如"阳光下移速-50%"），无需C#

📖 [基因效果分类与实现机制](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\基因效果分类与实现机制.md)

#### 3. 代谢效率与Biostat系统

三维度约束基因组合：

| 维度 | GeneDef字段 | 范围 | 影响 |
|------|-----------|------|------|
| Metabolism | `biostatMet` | -5~+5 | 食物消耗速率（-5=2.25×，+5=0.5×） |
| Complexity | `biostatCpx` | -5~+5 | 基因总量限制（基础最大=6）+组装时间 |
| Archite | `biostatArc` | 0+ | 需要稀有Archite胶囊 |

> **要点**：
> 1. 代谢曲线不对称：惩罚远大于收益（-5=2.25×消耗 vs +5=0.5×消耗）
> 2. 强力效果应有负代谢代价，负面效果给正代谢收益

📖 [代谢效率与Biostat系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\代谢效率与Biostat系统.md)

#### 4. 基因获得与移除途径

5种获得途径：出生继承、种族默认、Xenogerm植入、Xenogerm再植入、代码直接添加。

| # | 途径 | 基因类型 | 核心代码 |
|---|------|---------|---------|
| 1 | 出生继承 | Endogene | `PregnancyUtility.GetInheritedGenes()` |
| 2 | 种族默认 | Endogene | `PawnGenerator.GenerateGenes()` |
| 3 | Xenogerm植入 | Xenogene | `GeneUtility.ImplantXenogermItem()` |
| 4 | Xenogerm再植入 | Xenogene | `GeneUtility.ReimplantXenogerm()` |
| 5 | 代码直接添加 | 任意 | `Pawn_GeneTracker.AddGene()` |

> **要点**：
> 1. Xenogerm植入是"全替换"——清除全部旧Xenogene，防止基因无限堆叠
> 2. 遗传仅限Endogene——模组设计可遗传基因应确保作为Endogene添加

📖 [基因获得与移除途径](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\基因获得与移除途径.md)

#### 5. 模组自定义基因与扩展模式

4种扩展模式：

| # | 模式 | 需要C# | 适用场景 |
|---|------|--------|---------|
| 1 | **纯XML配置** | 否 | 标准效果（属性、能力、外观） |
| 2 | **DefModExtension** | 是 | 原版字段不够，需额外数据 |
| 3 | **自定义Gene子类** | 是 | 运行时逻辑（Tick、条件触发） |
| 4 | **Harmony补丁** | 是 | 修改原版行为、种族限制 |

> **要点**：
> 1. VEF的`GeneExtension`（50+扩展字段）是社区事实标准
> 2. 性能敏感——Tick中缓存引用、用TickInterval替代Tick、避免每帧反射查询

📖 [模组自定义基因与扩展模式](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\模组自定义基因与扩展模式.md)

---

## 第4章 装备与物品系统 ★★★

> **对应模组需求**：触发体（实体4）、触发芯片（实体5）、黑触发器（实体6）、紧急脱离（实体7）、R7触发体装载芯片、R6黑触发器叠加Trion、D3三层架构、D6普通vs黑触发器二元对立

### 引导问题

1. 装备的大类有哪些？（武器、衣服、盔甲……）它们的穿戴规则是什么？
2. 装备的品质系统是怎么工作的？品质影响哪些属性？
3. 你见过"装备上有插槽/组件"的模组吗？它们怎么实现的？
4. 物品（非装备）有哪些类型？（原材料、药品、组件……）
5. 你理解的物品堆叠规则是什么？什么能叠什么不能叠？
6. 装备对Pawn属性的影响是怎么叠加计算的？

### 你的笔记

#### 1. 装备大类与穿戴规则

三大类：**武器**（仅1把Primary）、**服装**（多件叠穿，层级+部位组冲突）、**腰带工具**（Belt层，不与其他层冲突）。

6层服装层级：OnSkin(0) → Middle(100) → Shell(200) → Belt(300) → Overhead(400) → EyeCover(500)。

穿戴冲突规则：同层级 + 干涉部位组重叠 = 冲突。不同层级永远不冲突。

> **要点**：
> 1. Belt层天然不冲突——bodyPartGroups只有Waist
> 2. 护甲逐层判定——从外到内遍历服装，每层独立随机判定

📖 [装备大类与穿戴规则](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\装备大类与穿戴规则.md)

#### 2. 品质系统

7级品质：Awful → Poor → Normal → Good → Excellent → Masterwork → Legendary。

两种影响机制：**倍率型**（`StatPart_Quality`，每个Stat独立配置7级倍率）和**偏移型**（`StatPart_Quality_Offset`，直接加减）。影响：耐久度、护甲、保暖/隔热、美观、舒适度、武器伤害、市场价值。

> **要点**：
> 1. 每个Stat独立配置品质曲线——不存在"统一品质倍率"
> 2. 有品质的物品不能与不同品质的同类堆叠

📖 [品质系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\品质系统.md)

#### 3. 装备插槽/组件系统

3个DLC系统实现"装备上有插槽/组件"：

| 维度 | Odyssey独特武器 | Royalty心灵武器 | Anomaly装备能力 |
|------|----------------|----------------|-----------------|
| **核心Comp** | `CompUniqueWeapon` | `CompBladelinkWeapon` | `CompEquippableAbilityReloadable` |
| **特质数量** | 1-3个 | 1-2个 | 0（能力而非特质） |
| **"插槽"类比** | 武器类别=插槽类型，特质=组件 | 固定BladeLink类别 | 单一能力槽 |

> **要点**：
> 1. Odyssey是最佳"插槽/组件"参考——WeaponCategoryDef分类 + exclusionTags互斥 + WeaponTraitDef效果
> 2. WeaponTraitDef是Royalty和Odyssey共用的——通过WeaponCategoryDef区分适用范围

📖 [装备插槽与组件系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\装备插槽与组件系统.md)

#### 4. 物品类型总览

双层分类体系：底层`ThingCategory`枚举（11值，决定引擎行为）+ 上层`ThingCategoryDef`树（60+节点，面向玩家UI分类）。

9个物品相关一级分支：Foods、ResourcesRaw、Manufactured、Items、Weapons、Apparel、Chunks、Corpses、Buildings。

> **要点**：
> 1. 武器和服装在枚举层面与原材料同属`ThingCategory.Item`，区分靠ThingCategoryDef树
> 2. Stuff材料影响堆叠——不同Stuff的同类物品不可堆叠

📖 [物品分类与堆叠系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\物品分类与堆叠系统.md)

#### 5. 物品堆叠规则

3层判定链：`Thing.CanStackWith`（基础5项）→ `ThingWithComps.CanStackWith`（Comp扩展）→ `TransferableUtility.CanStackTogether`（远行队/贸易）。

核心阻断因素：不同ThingDef、不同Stuff材料、不同品质、有艺术品属性、不同成分、不同基因集。

> **要点**：
> 1. Comp是堆叠规则的扩展点——自定义ThingComp的`AllowStackWith()`可添加任意堆叠条件
> 2. `TryAbsorbStack`合并时HitPoints取加权平均，非简单相加

📖 [物品分类与堆叠系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\物品分类与堆叠系统.md)

#### 6. 装备属性叠加计算

三条路径影响Pawn属性：

| 路径 | 数据来源 | 叠加方式 | 典型场景 |
|------|---------|---------|---------|
| `equippedStatOffsets` | ThingDef声明 | 加法 | 武器给Pawn射击精度+0.5 |
| `StatPart_GearStatOffset` | 装备自身Stat值 | 加法累加 | 服装护甲值加到Pawn护甲 |
| `StatPart_GearStatFactor` | 装备自身Stat值 | 乘法连乘 | 装备的射击精度因子 |

> **要点**：
> 1. `equippedStatOffsets`是"穿上后给Pawn的加成"，`statBases`是"装备自身属性"
> 2. 品质双重影响——既影响装备自身Stat，也影响equippedStatOffsets的偏移量

📖 [装备属性叠加计算](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\装备属性叠加计算.md)

---

## 第5章 能力与特性系统 ★★☆

> **对应模组需求**：Trion表现、副作用（实体3）、R5 Trion触发副作用

### 引导问题

1. Ability（能力）系统的基本结构是什么？（冷却、目标选择、效果……）
2. 你见过哪些能力的例子？（超能力、机械师能力、基因能力……）
3. Trait（特性）是什么？它和Hediff有什么区别？
4. 特性能在游戏中途获得或移除吗？你知道哪些途径？
5. 能力和特性之间有关联吗？（比如某个特性赋予某个能力）

### 你的笔记

#### 1. Ability系统基本结构

三层架构：`AbilityDef`（定义层，50+字段）→ `Ability`（实例层，实现`IVerbOwner`）→ `Pawn_AbilityTracker`（管理层，聚合7个来源）。

能力效果全靠`CompAbilityEffect`（30+子类，分8类：状态施加/传送/伤害/治疗/社交/资源/视觉/其他）。7个来源：直接能力、Hediff、装备、服装、变异体、皇室、意识形态角色。

> **要点**：
> 1. 模组新增能力优先用XML——定义AbilityDef + 组合现有CompAbilityEffect子类即可
> 2. Psycast是Ability的唯一子类——其他所有能力直接使用Ability基类

📖 [Ability系统基本结构](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Ability系统基本结构.md)

#### 2. 各DLC能力实例与分类

| DLC | 能力数量 | 能力类型 | abilityClass | 获得途径 |
|-----|---------|---------|-------------|---------|
| **Royalty** | 20+ | 超能力 | `Psycast` | 心灵连接等级解锁 |
| **Biotech** | 5+ | 基因能力 | `Ability`基类 | GeneDef.abilities |
| **Ideology** | 5+ | 角色能力 | `Ability`基类 | Precept_Role角色赋予 |
| **Anomaly** | 5+ | 变异体/装备能力 | `Ability`基类 | MutantDef / CompEquippableAbility |

> **要点**：
> 1. 只有Royalty超能力使用Psycast子类，其他DLC全部使用Ability基类
> 2. 模组能力来源选择：直接能力（永久）、Hediff能力（条件性）、装备能力（物品附带）、基因能力（种族特性）

📖 [各DLC能力实例与分类](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\各DLC能力实例与分类.md)

#### 3. Trait特性系统与Hediff对比

| 维度 | Trait（特性） | Hediff（健康状况） |
|------|-------------|-------------------|
| **附加位置** | `Pawn.story.traits` | `Pawn.health.hediffSet` |
| **数量限制** | 通常3-4个 | 无上限 |
| **严重度** | 无Severity，用degree（离散整数） | 有Severity（连续浮点） |
| **时间性** | 永久性 | 可临时/永久 |
| **组件系统** | 无Comp | 有HediffComp |

核心设计哲学：Trait = 角色个性（"是什么样的人"），Hediff = 健康状态（"身上发生了什么"）。

两种TraitDef类型：**单一型**（1个degree，如Bloodlust）和**光谱型**（多个degree，如SpeedOffset: -1慢吞吞/+1快步/+2慢跑者）。

> **要点**：
> 1. 需要随时间变化的效果用Hediff，永久性角色特征用Trait
> 2. 压制≠移除——被基因压制的特质仍在列表中，恢复压制源后自动恢复

📖 [Trait特性系统与Hediff对比](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Trait特性系统与Hediff对比.md)

#### 4. Trait获得与移除途径

7种获得：角色生成、背景故事强制、场景强制、基因强制、成长时刻、异常加入者、代码直接调用。
4种移除：基因移除联动、代码直接调用、调试工具、新Xenogerm植入。

> **要点**：
> 1. 基因是Trait的主要动态来源——`GeneDef.forcedTraits`/`suppressedTraits`是运行时增删特质的主要途径
> 2. RemoveTrait会反向移除sourceGene——移除基因强制的特质会连带移除基因本身

📖 [Trait特性系统与Hediff对比](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Trait特性系统与Hediff对比.md)

#### 5. 能力与特性的关联机制

5条关联路径：

| # | 路径 | 机制 | 原版使用情况 |
|---|------|------|-------------|
| 1 | Trait→Ability（直接赋予） | `TraitDegreeData.abilities` | 代码支持，原版XML未使用 |
| 2 | Gene→Trait + Gene→Ability（并行） | 各自独立生效 | 常见 |
| 3 | Trait→Need→间接影响 | Need影响能力使用条件 | 常见 |
| 4 | Trait→冥想→Psyfocus→Psycast | 冥想效率影响超能力 | 常见 |
| 5 | Gene压制Trait→影响Ability | 被压制特质的abilities不生效 | 理论支持 |

> **要点**：
> 1. `TraitDegreeData.abilities`是Trait赋予Ability的唯一直接通道——原版未使用，模组使用属于"合法但非主流"
> 2. Gene的forcedTraits和abilities是并行独立的——不存在Gene通过Trait间接赋予Ability的链条

📖 [能力与特性关联机制](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\能力与特性关联机制.md)

---

## 第6章 战斗系统 ★★★

> **对应模组需求**：R11触发体激活战斗体、R16伤害隔离、R18紧急脱离传送Job、D4伤害隔离是战略核心、Gizmo/命令按钮（芯片切换UI）、Job/工作系统

### 引导问题

1. 一次攻击从发起到造成伤害，你理解的大致过程是什么？（命中、闪避、护甲、伤害类型……）
2. RimWorld有哪些伤害类型？不同伤害类型的效果有什么区别？（锐器、钝器、烧伤、EMP……）
3. 原版有哪些减少或避免伤害的手段？（护甲、护盾、掩体、闪避……）它们各自的效果和限制是什么？
4. 战斗中Pawn会做哪些行为？玩家能下达哪些命令？（射击、近战、掩蔽、逃跑、征召、使用能力……）
5. 战斗中有哪些"极端情况"或"安全网"机制？（Pawn倒下后怎样、即死保护、精神崩溃、逃跑……）
6. RimWorld中有没有Pawn暂时变成另一种形态或状态的先例？（变异体转化、机械体关机/重启、死眠……）变化前后有什么区别？
7. 你见过模组改变或扩展战斗系统的例子吗？（新伤害类型、新护盾、战斗机制改动……）
8. Gizmo（命令按钮）是什么？你在游戏中见过哪些？（征召按钮、能力按钮、装备切换……）
9. 你理解的Job系统是什么？Pawn怎么决定"下一步做什么"？
10. 战斗中的Job和日常Job有什么不同？

### 你的笔记

#### 1. 完整伤害管线（Attack → Hediff_Injury）

一次攻击完整经过7个阶段，提供10个伤害拦截/修改点：

```
┌─────────────────────────────────────────────────────────────────┐
│                    完整伤害管线 7阶段流程                         │
├─────────────────────────────────────────────────────────────────┤
│  1.Verb.TryCastShot ── Miss/Dodge? ──Yes──→ [无伤害]           │
│           │ Hit                                                  │
│  2.DamageInfo创建（伤害量、穿甲值、攻击者、武器）                │
│           │                                                      │
│  3.Thing.TakeDamage ──→ ThingDef.damageMultipliers              │
│           │                                                      │
│  4.PreApplyDamage拦截链                                         │
│    基因damageFactors → Hediff damageFactors → CompShield → 护盾 │
│           │ absorbed? ──Yes──→ [无伤害]                          │
│           │ No                                                   │
│  5.DamageWorker: 部位选择 → 逐层护甲判定                        │
│           │ deflected? ──Yes──→ [无伤害]                         │
│           │ No                                                   │
│  6.FinalizeAndAddInjury ──→ 即死保护(殖民者) → Hediff_Injury    │
│           │                                                      │
│  7.PostApplyDamage: 死亡判定 → 附加Hediff → 通知链              │
└─────────────────────────────────────────────────────────────────┘
```

| # | 阶段 | 核心类/方法 | 关键决策 |
|---|------|-----------|---------|
| 1 | 攻击发起 | `Verb_MeleeAttack` / `Verb_LaunchProjectile` | 命中/闪避判定 |
| 2 | 投射物命中 | `Bullet.Impact` | DamageInfo创建 |
| 3 | TakeDamage入口 | `Thing.TakeDamage` | ThingDef倍率 |
| 4 | PreApplyDamage | `Pawn→ThingWithComps→HealthTracker` | 基因/Hediff倍率、护盾吸收 |
| 5 | DamageWorker | `DamageWorker_AddInjury` | 部位选择、逐层护甲 |
| 6 | 伤害最终化 | `FinalizeAndAddInjury` | 即死保护、Hediff_Injury创建 |
| 7 | 后处理 | `PostApplyDamage` | 死亡判定、附加Hediff |

> **要点**：
> 1. PreApplyDamage是模组拦截伤害的最佳位置——自定义ThingComp的`PostPreApplyDamage`可修改或吸收伤害，无需Harmony
> 2. 基因和Hediff的damageFactors在护甲之前生效（阶段4先乘倍率，阶段5再算护甲）
> 3. CompShield不拦截近战——只拦截`isRanged || isExplosive`的伤害

📖 [战斗伤害管线完整流程](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\战斗伤害管线完整流程.md)

#### 2. 伤害类型分类与DamageDef体系

RimWorld共约50种伤害类型（Core ~36 + Biotech 3 + Anomaly 6 + Odyssey 7），通过`DamageDef`定义。每种伤害类型的行为由三个维度决定——护甲类别（决定哪个护甲Stat防御）、DamageWorker子类（14种，决定伤害如何分配到部位）、行为标志位（决定护盾交互和系统行为）。

**按护甲类别分4大类**：

| 护甲类别 | 防御Stat | 典型伤害类型 | 数量 |
|---------|---------|------------|------|
| **Sharp（锐器）** | ArmorRating_Sharp | Cut, Stab, Bullet, Arrow, Bomb, Scratch, Bite, AcidBurn, EnergyBolt | ~23 |
| **Blunt（钝器）** | ArmorRating_Blunt | Blunt, Crush, Poke, Demolish | 4 |
| **Heat（热能）** | ArmorRating_Heat | Flame, Burn, Vaporize, Beam | ~7 |
| **无** | 无护甲防御 | Stun, EMP, Frostbite, SurgicalCut, Psychic | ~16 |

**DamageWorker决定伤害分配行为**：

| Worker | 特殊行为 | 使用者 |
|--------|---------|--------|
| AddInjury | 基础：单部位伤害 | Bullet, Bomb, Burn, Arrow等 |
| Cut | 劈砍溢出到相邻部位（cutCleaveBonus） | Cut |
| Blunt | 内部冲击（40%概率）+ 眩晕概率 | Blunt |
| Stab | 强制穿透到内部器官（60%概率） | Stab, RangedStab, Poke |
| Scratch | 伤害分裂到2个部位（67%/67%） | Scratch |
| Flame | 点燃目标 + 地面起火 | Flame |
| Stun | 仅眩晕，不造成健康伤害 | Stun, EMP, MechBandShockwave |
| Nerve | 造成伤害 + 追加NerveStun眩晕 | Nerve |
| Vaporize | 内圈蒸发 + 起火 | Vaporize |

> **要点**：
> 1. **护盾交互由3个标志位控制**——CompShield拦截条件是`!ignoreShields && (isRanged || isExplosive)`，近战伤害直接穿过护盾；原版仅Odyssey的BeamBypassShields使用`ignoreShields=true`
> 2. **自定义伤害类型优先用XML继承**——通过`ParentName`继承现有DamageDef（如Bullet、Scratch），只需覆盖差异字段（如additionalHediffs），无需写C#
> 3. **additionalHediffs有两个层级**——`additionalHediffs`在PostApplyDamage中全局添加（如ToxicBite→ToxicBuildup），`additionalHediffsThisPart`在FinalizeAndAddInjury中同部位添加（如PorcupineBite→PorcupineQuill）

📖 [伤害类型分类与DamageDef体系](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\伤害类型分类与DamageDef体系.md)

#### 3. 伤害减免机制总览（6种手段）

RimWorld有6种减少或避免伤害的机制，按管线位置从早到晚：**未命中**（阶段1）→ **闪避**（阶段1，近战专属）→ **掩体**（阶段1，远程专属）→ **护盾**（阶段1/4）→ **伤害因子**（阶段3-5）→ **护甲**（阶段5）。前3种是"避免伤害"（二元判定），后3种是"减少伤害"（数值削减）。

| # | 机制 | 生效阶段 | 适用攻击 | 核心类 | 效果类型 |
|---|------|---------|---------|--------|---------|
| 1 | **未命中** | 1 | 远程+近战 | `ShotReport` / `GetNonMissChance` | 完全避免 |
| 2 | **闪避** | 1 | 仅近战 | `GetDodgeChance` | 完全避免 |
| 3 | **掩体** | 1 | 仅远程 | `CoverUtility` | 完全避免 |
| 4 | **护盾** | 1/4 | 远程+爆炸 | `CompShield` / `CompProjectileInterceptor` | 完全吸收 |
| 5 | **伤害因子** | 3-5 | 全部 | `GeneDef`/`HediffStage`/`StatDef` | 倍率削减 |
| 6 | **护甲** | 5 | 有armorCategory的 | `ArmorUtility` | 随机偏转/半减/穿透 |

**各机制核心要点**：

1. **未命中** — 远程：`TotalHitChance = AimOnTargetChance × PassCoverChance`，射手精度^距离 × 武器 × 天气 × 烟雾 × 姿态，最低2.01%，4距离段（Touch 0-3 / Short 3-12 / Medium 12-25 / Long 25-40）。近战：`MeleeHitChance` stat，突袭/不动目标=100%命中。
2. **闪避** — 仅近战，`MeleeDodgeChance` stat。禁用条件：突袭、目标不动、目标使用远程武器。Ideology DLC加4种光照偏移。
3. **掩体** — 仅远程，`fillPercent`决定基础格挡率（Full填充=75%）。角度调整5档（<15°=100%到≥65°=无效），距离调整3档（<1.9格=33%到≥2.9格=100%）。多掩体递减公式：`total += (1-total) × blockChance`。
4. **护盾** — 详见第6章第1节伤害管线阶段4，📖 [护盾机制与伤害吸收系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\护盾机制与伤害吸收系统.md)
5. **伤害因子** — 基因`damageFactors`（阶段4，护甲前，乘算）、Hediff当前阶段`damageFactors`（阶段4，护甲前，乘算）、`IncomingDamageFactor` stat（阶段5，护甲后）。
6. **护甲** — `effectiveArmor = max(armorRating - armorPenetration, 0)`，三结果随机：<eA×0.5=完全偏转，<eA=半减+Sharp→Blunt，else=穿透。逐层判定（从外到内），护甲磨损25%原始伤害，MaxArmorRating=2.0。

> **要点**：
> 1. **远程没有闪避，近战没有掩体**——RimWorld战斗的核心不对称设计
> 2. **基因/Hediff的damageFactors在护甲之前生效**——先乘倍率再算护甲，抗性基因减少的是护甲前的原始伤害
> 3. **掩体对近距离射击效果大幅降低**——<1.9格仅33%效果，这解释了为什么近距离战斗中掩体不太有用

📖 [伤害减免机制总览](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\伤害减免机制总览.md)

#### 4. 战斗行为与玩家命令

战斗行为由三层系统协作：**征召系统**（Draft，切换战斗模式）→ **Job系统**（具体行为）→ **Verb+Stance系统**（单次攻击节奏）。

**征召系统核心**：`Pawn_DraftController.Drafted` setter含大量副作用——征召时清除工作队列、唤醒休眠、离开Lord；解除征召时释放预订、中断Job、重置动物。`AutoUndrafter`在10000 ticks无威胁后自动解除。`FireAtWill`控制远程自动射击（不影响近战）。

**6个核心战斗Job**：

| # | JobDef | 触发方式 | 核心行为 |
|---|--------|---------|---------|
| 1 | **Wait_Combat** | 征召后默认 | 原地待命 + 自动射击（每4 tick检查） |
| 2 | **AttackStatic** | 右键敌人(远程) | 固定位置远程射击 |
| 3 | **AttackMelee** | 右键敌人(近战) | 追踪+近战攻击 |
| 4 | **Goto** | 右键地面 | 移动到目标位置 |
| 5 | **CastAbility** | 能力按钮 | 施放能力(含预热+冷却) |
| 6 | **Flee** | AI逃跑决策 | 逃离威胁源 |

**Wait_Combat自动射击优先级**：近战（9格内敌人）> 灭火 > 远程射击。FireAtWill仅控制远程。

**Gizmo命令来源**：征召控制器（征召按钮+自由射击）、能力追踪器（能力按钮）、装备/Hediff/基因的Comp。

**Stance攻击节奏**：`Stance_Warmup`（预热/瞄准）→ `Verb.TryCastShot`（连发）→ `Stance_Cooldown`（冷却）→ 回到`Stance_Mobile`。

**AI战斗决策**：`JobGiver_AIFightEnemy`通过`AttackTargetFinder`在56格内搜索目标，按能力→近战→远程优先级生成Job。`HostilityResponseMode`三种模式：Ignore/Attack/Flee。

> **要点**：
> 1. **Wait_Combat是自动射击的引擎**——模组自定义战斗行为可通过Harmony Patch `CheckForAutoAttack()` 介入自动目标选择
> 2. **Gizmo是模组添加战斗命令的标准方式**——ThingComp/HediffComp/Gene/Ability的`GetGizmos()`都会被收集，`displayGizmoWhileUndrafted`控制未征召时显示
> 3. **Verb+Stance控制攻击节奏**——自定义武器只需配置VerbProperties的warmupTime/burstShotCount/cooldownTime，无需写C#

📖 [战斗行为与玩家命令系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\战斗行为与玩家命令系统.md)

#### 5. 战斗极端情况与安全网机制

RimWorld内置7层战斗安全网，从伤害最终化到倒地后行为层层递进：

| # | 安全网 | 生效位置 | 保护对象 | 核心机制 |
|---|--------|---------|---------|---------|
| 1 | **即死保护** | 阶段6 FinalizeAndAddInjury | 仅殖民者 | 最多7次迭代削减伤害至不致死 |
| 2 | **preventsDeath** | ShouldBeDead | 有该Hediff的Pawn | 跳过所有死亡判定 |
| 3 | **不死基因** | CheckForStateChange | Deathless基因持有者 | 死眠/昏迷替代死亡（大脑完好时） |
| 4 | **倒地替代死亡** | CheckForStateChange | 所有Pawn | ShouldBeDowned→MakeDowned |
| 5 | **倒地即死概率** | CheckForStateChange | 非玩家Pawn | 按类型/难度/人口意图概率判定 |
| 6 | **爬行** | 倒地后行为 | 人形+清醒+操作≥15% | 可爬行逃离/去床位 |
| 7 | **恢复** | CheckForStateChange | 所有倒地Pawn | 伤势好转→MakeUndowned |

**即死保护**：`allowInstantKillChance`难度滑块（默认1.0=无保护），触发时在`FinalizeAndAddInjury`中最多7次迭代削减伤害，每次翻倍削减量，直到`WouldDieAfterAddingHediff`返回false。仅限殖民者+外部暴力。

**倒地状态机**：`CheckForStateChange()`统一调度三级状态（Mobile→Down→Dead）。倒地触发条件：疼痛休克（PainTotal ≥ PainShockThreshold）、无法清醒、无法移动、生命阶段强制。`MakeDowned()`有15+副作用：掉装备、取消征召、清除Job、通知Lord等。

**倒地即死概率**：机械体100%、动物50%、人形基于人口意图曲线（缺人时降至26%）×难度系数。玩家殖民者不触发此系统。`forceDeathOnDowned`标记可强制倒地即死。

> **要点**：
> 1. 即死保护仅限殖民者+外部暴力——模组的"伤害隔离"本质上是自定义安全网，可参考此机制的ThingComp拦截模式
> 2. 非玩家Pawn的倒地即死概率受人口意图动态调节——游戏自动平衡俘虏供给，模组设计敌方Pawn时需考虑此机制

📖 [战斗极端情况与安全网机制](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\战斗极端情况与安全网机制.md)

#### 6. Pawn形态与状态切换先例

RimWorld有5种Pawn形态/状态切换机制，按变化深度从深到浅：

| # | 先例 | DLC | 核心系统 | 变化深度 | 可逆性 |
|---|------|-----|---------|---------|--------|
| 1 | **变异体转化** | Anomaly | `MutantDef` + `Pawn_MutantTracker` | ★★★ 全面改变 | 部分（Revert不完全） |
| 2 | **非人化** | Anomaly | `Hediff_Inhumanized` | ★★☆ 行为改变 | 完全可逆 |
| 3 | **死眠** | Biotech | `Gene_Deathrest` + `Hediff_Deathrest` + `Need_Deathrest` | ★★☆ 休眠状态 | 自动恢复 |
| 4 | **机械体自动关机** | Biotech | `Need_MechEnergy` + SelfShutdown Hediff | ★☆☆ 休眠状态 | 自动恢复(能量≥15) |
| 5 | **机械体停用** | Biotech | `CompMechanoid.Deactivate()` | ★☆☆ 休眠状态 | 手动WakeUp() |

5种实现模式：**专用Tracker**（变异体，全面改变）、**Hediff标记**（非人化，轻量可逆）、**三层架构**（死眠，Gene+Need+Hediff协作）、**Need驱动**（机械体关机，自动状态切换）、**Comp驱动**（机械体停用，手动控制）。

> **要点**：
> 1. 变异体Turn()有20+副作用链，Revert()仅部分恢复（装备/基因/所有权不恢复）——变异体转化在设计上是"准永久"的
> 2. 非人化是最轻量的状态切换——单Hediff + 30+分散检查点，完全可逆无副作用，是"Hediff作为状态标记"的典范

📖 [Pawn形态与状态切换先例](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Pawn形态与状态切换先例.md)

#### 7. 模组扩展战斗系统实例

社区模组通过5种技术路径扩展战斗系统，按侵入性从低到高：

| # | 技术路径 | 实现方式 | 典型模组 | 适用场景 |
|---|---------|---------|---------|---------|
| 1 | **XML继承DamageDef** | 纯XML | 大多数模组 | 新伤害类型（改数值/标志位） |
| 2 | **自定义DamageWorker** | C#继承 | VEF, GD3(闪耀毁灭) | 特殊伤害逻辑（毒性/心灵/感染） |
| 3 | **自定义Verb** | C#继承 | CeleTech(天工铸造), AncotLib | 新攻击方式（激光/蓄力/跳跃） |
| 4 | **ThingComp/HediffComp** | C#组件 | VEF | 新护盾/伤害拦截/武器附加效果 |
| 5 | **Harmony补丁** | C#补丁 | VEF, AncotLib | 修改原版管线（护甲/命中/伤害） |

4大类代表性实例：自定义DamageWorker（VEF ExtraInfecter攻击附加感染、GD3 PsychicStrike按心灵敏感度分级效果）、自定义护盾（VEF HediffComp_Shield——唯一基于Hediff的护盾，支持近战/远程/全部吸收+能量系统+伤害反射）、Harmony补丁（AncotLibrary PreApplyDamage补丁——让武器Comp也能拦截伤害）、自定义Verb（AncotLibrary蓄力近战Verb+CompWeaponCharge协作、CeleTech持续激光束）。

> **要点**：
> 1. 模组扩展战斗系统优先用Comp（无侵入），其次用继承（DamageWorker/Verb），最后用Harmony补丁（有兼容风险）
> 2. AncotLibrary的PreApplyDamage补丁揭示了原版盲点——武器的ThingComp不参与伤害拦截，需要Harmony补丁补全

📖 [模组扩展战斗系统实例](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\模组扩展战斗系统实例.md)

#### 8. Gizmo命令按钮系统

Gizmo是选中物体后屏幕底部显示的命令按钮/状态条的统称。三层架构：类继承体系 → 收集机制 → 分组渲染。

**Gizmo三层架构总览**：

```
类继承体系                    收集机制                      分组渲染
─────────────                ──────────                    ──────────
Gizmo（基类）                GizmoGridDrawer               Command.GroupsWith()
├─ Command（按钮）           ├─ ISelectable.GetGizmos()    ├─ groupKey 内容匹配
│  ├─ Action/Toggle/Target   │  └─ Pawn: 28个提供者        │  （hotKey+Label+icon+groupKey）
│  ├─ VerbTarget/Ability     ├─ 反向设计器注入              └─ groupKeyIgnoreContent
│  └─ Designator             └─ DrawGizmoGrid()渲染            忽略内容匹配
├─ Gizmo_Slider（滑块）
└─ 状态显示Gizmo ×13+
```

**6个核心Command类型对比**：

| 类型 | 核心字段 | 用途 | 典型实例 |
|------|---------|------|---------|
| `Command_Action` | `Action action` | 点击执行 | 征召、开门、引爆 |
| `Command_Toggle` | `isActive` + `toggleAction` | 开关切换 | 自由射击、保持征召 |
| `Command_Target` | `Action<LocalTargetInfo>` | 选目标执行 | 指定攻击目标 |
| `Command_VerbTarget` | `Verb verb` | Verb攻击命令 | 远程射击、炮塔攻击 |
| `Command_Ability` | `Ability ability` | 能力按钮 | 灵能力、基因能力 |
| `Designator` | `DesignationDef` | 建造/指定 | 建墙、砍伐、采矿 |

**Pawn的Gizmo来源分类**：

| 分类 | 提供者 | 典型Gizmo | DLC |
|------|--------|----------|-----|
| **核心控制** | drafter、attackGizmos | 征召/解除、自由射击、攻击 | Core |
| **装备/物品** | equipment、apparel、inventory、carryTracker | 装备命令、护盾条、穿戴Verb | Core |
| **能力/基因** | abilities、genes、psychicEntropy | 能力按钮、血源条、灵能熵条 | Core/Biotech/Royalty |
| **健康/Hediff** | health（→HediffComp.CompGetGizmos） | 死亡拒绝、怀孕、金属恐怖 | Core |
| **机械师** | mechanitor、mechGizmos、Gizmo_GrowthTier | 带宽条、控制组、成长等级 | Biotech |
| **皇室** | royalty permits、titles、royalAid | 许可按钮、援助按钮 | Royalty |
| **其他** | quest、connections、training、lord、mutant | 任务按钮、连接、训练、领主命令 | 各DLC |

**自定义Gizmo类型分类**：

| 分类 | 数量 | 代表 | 特点 |
|------|------|------|------|
| 状态显示（继承Gizmo） | 13+ | 护盾能量条、灵能熵、机械师带宽 | 纯显示，自定义GizmoOnGUI渲染 |
| 滑块（继承Gizmo_Slider） | 4 | 燃料目标、基因资源条、血源条 | 可拖拽设置目标值 |
| 专用Command（继承Command） | 8 | 仪式、种植设置、床位归属 | 打开专用选择窗口 |

> **要点**：
> 1. 模组添加Gizmo最常用的方式是`ThingComp.CompGetGizmosExtra()`——无侵入，自动被ThingWithComps.GetGizmos()收集
> 2. 穿戴装备有专用通道`CompGetWornGizmosExtra()`——护盾腰带的能量条就是通过这个通道显示的

📖 [Gizmo命令按钮系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Gizmo命令按钮系统.md)

#### 9. Job系统架构与调度机制

Job系统是Pawn行为的核心驱动，五层架构：

```
ThinkTree(决策层) → JobGiver(生成层) → Job(数据层) → JobDriver(执行层) → Toil(原子层)
```

**6个核心类对比**：

| 核心类 | 职责 | 关键字段/方法 |
|--------|------|-------------|
| `Pawn_JobTracker` | 调度器 | curJob/curDriver/jobQueue; DetermineNextJob/StartJob/EndCurrentJob/CheckForJobOverride |
| `ThinkTree/ThinkNode` | 决策树 | ThinkNode_Priority按序遍历; ThinkNode_PrioritySorter按GetPriority()动态排序 |
| `ThinkNode_JobGiver` | 叶节点 | TryGiveJob()生成Job实例 |
| `Job` | 纯数据容器 | def+targetA/B/C+expiryInterval+playerForced+checkOverrideOnDamage |
| `JobDriver` | 执行器 | MakeNewToils()定义Toil序列; DriverTick()每tick驱动 |
| `Toil` | 最小执行单元 | initAction/tickAction/defaultCompleteMode(5种) |

**Humanlike ThinkTree优先级结构**（简化版）：

- **ConstantThinkTree**（每30 ticks检查）：逃爆炸 > 寻氧 > 敌对响应(★) > Lord紧急指令
- **MainThinkTree**（Job结束时遍历）：躺下 > 倒地 > 着火 > 精神崩溃 > 近战威胁反应 > **征召命令(Orders)** > 紧急工作 > Lord指令 > **MainColonistBehaviorCore**(需求+工作) > 空闲

**MainColonistBehaviorCore**：ThinkNode_PrioritySorter按GetPriority()动态排序（先随机打乱再取最高）——工作时间段：GetFood(9.5) > Work(9.0) > GetRest(仅极度疲劳8.0)；任意时间段：GetFood(9.5) > GetRest(8.0) > GetJoy(6.0, 仅Joy<0.35) > Work(5.5)。

**Job生命周期6步**：DetermineNextJob() → StartJob(创建Driver+预留资源) → SetupToils(构建Toil列表) → DriverTick(每tick执行当前Toil) → ReadyForNextToil(推进) → EndCurrentJob(清理+TryFindAndStartJob)

**ToilCompleteMode 5种**：Instant(立即) / PatherArrival(到达) / Delay(延时) / FinishedBusy(外部标记) / Never(永不自动完成)

> **要点**：
> 1. 自定义Job只需3步：JobDef(XML) + JobDriver子类(C#重写MakeNewToils) + JobGiver或Gizmo触发
> 2. ThinkNode_SubtreesByTag是模组插入ThinkTree的标准方式——4个插入点：PostMentalState/PostDuty/PreMain/PostMain
> 3. WorkGiver_Scanner是日常工作的标准扩展点——重写PotentialWorkThingsGlobal()+JobOnThing()

📖 [Job系统架构与调度机制](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Job系统架构与调度机制.md)

#### 10. 战斗Job与日常Job差异对比

**核心差异总览表**（8个维度）：

| 维度 | 战斗Job | 日常Job |
|------|---------|---------|
| 触发方式 | 玩家命令/AI敌对响应 | ThinkTree自动分配 |
| ThinkTree位置 | Orders(高优先级)/ConstantThinkTree | MainColonistBehaviorCore(低优先级) |
| 典型JobDef | AttackStatic/AttackMelee/Wait_Combat | HaulToCell/DoBill/Mine |
| casualInterruptible | `false`（不可随意中断） | 默认`true` |
| checkOverrideOnDamage | 默认Always | 默认Always |
| expiryInterval | 有（定期重新评估目标，~450-550 ticks） | 无（-1，完成即结束） |
| suspendable | `false`（显式设置，默认值实为true） | `false`（显式设置，默认值实为true） |
| allowOpportunisticPrefix | `false` | `true`（顺路搬运） |

**战斗如何打断日常工作**（3条路径）：
1. **ConstantThinkTree敌对响应**：每30 ticks检查 → JobGiver_ConfigurableHostilityResponse → 生成战斗Job → InterruptForced打断当前工作
2. **受伤触发重新评估**：Notify_DamageTaken → checkOverrideOnDamage=Always → CheckForJobOverride → 重新评估
3. **玩家征召**：Drafted setter清除工作队列 → EndCurrentJob(InterruptForced) → Orders节点生成Wait_Combat

**日常工作恢复**：suspendable默认值为true，但原版几乎所有JobDef显式设为false → 被打断后不恢复，重新从ThinkTree分配新工作。

**expiryInterval机制**（战斗Job特有）：战斗Job设置expiryInterval(~450-550 ticks) + checkOverrideOnExpire=true → 到期时CheckForJobOverride重新评估目标。expireRequiresEnemiesNearby=true → 附近无敌人时才过期。

**TryTakeOrderedJob流程**（玩家命令）：playerForced=true → 检查IsCurrentJobPlayerInterruptible → 清除队列 → EndCurrentJob(InterruptForced) → StartJob。

> **要点**：
> 1. 自定义战斗Job关键字段：`casualInterruptible=false` + `alwaysShowWeapon=true` + `collideWithPawns=true`
> 2. 自定义工作Job关键字段：`allowOpportunisticPrefix=true` + checkOverrideOnDamage默认Always（受伤可被战斗打断）

📖 [战斗Job与日常Job差异对比](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\战斗Job与日常Job差异对比.md)

---

## 第7章 派系系统 ★★☆

> **对应模组需求**：BORDER（实体12）、敌对惑星国家派系（实体13）、R21近界民操控Trion兵

### 引导问题

1. 原版有哪些派系类型？（玩家、友好、中立、敌对、机械族……）
2. 派系关系是怎么变化的？（好感度、贸易、袭击……）
3. 派系的Pawn有什么特征？（装备水平、科技水平、行为模式……）
4. 你见过模组自定义的派系吗？它们和原版派系有什么不同？
5. 派系和袭击之间的关系是什么？哪些派系会来袭击？

### 你的笔记

#### 1. 原版派系类型总览

RimWorld派系系统采用三层架构：`FactionDef`（XML静态定义）→ `Faction`（运行时实例，持有好感度/领袖/成员）→ `FactionManager`（全局管理器）。全部~28个原版派系分布在6个DLC中。

**按敌对性分4类速查**：

| 分类 | 数量 | 代表派系 | 特征 |
|------|------|---------|------|
| **永久敌对**（permanentEnemy） | 11 | Pirate, TribeSavage, Mechanoid, Salvagers | 好感度锁定-100，不可和解 |
| **特殊永久敌对**（permanentEnemyToEveryoneExcept） | 3 | Empire, Insect, Entities | 对大多数派系敌对，但有例外列表 |
| **自然敌对**（naturalEnemy） | 4 | OutlanderRough, TribeRough + Biotech变体 | 初始-80，可通过外交和解 |
| **中立/友好** | 6 | OutlanderCivil, TribeCivil, Empire(对玩家), TradersGuild | 初始好感度0 |

**按科技等级分类**：

| 科技等级 | 派系 |
|---------|------|
| Animal | Insect, Entities |
| Neolithic | 所有Tribe变体, Beggars, Pilgrims |
| Industrial | 所有Outlander变体, PlayerColony |
| Spacer | 所有Pirate变体, HoraxCult, TradersGuild, Salvagers, Ancients |
| Ultra | Empire, Mechanoid |

> **要点**：
> 1. Biotech种族变体通过`replacesFaction`替换Core派系，同一存档不会同时存在原版和变体
> 2. `PirateBandBase`（defName=Pirate）既是具体派系又是其他海盗变体的父级——特殊设计
> 3. `hidden=true`的派系不在世界地图生成定居点，但仍可作为袭击来源（除非`raidsForbidden`）

📖 [原版派系类型总览](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\原版派系类型总览.md)

#### 2. 派系关系变化机制

派系关系采用双层架构：`FactionRelation`（好感度值+关系类型）× `GoodwillSituationManager`（情境修正系统）。

**三级关系与阈值**：

| 关系 | 好感度范围 | 效果 |
|------|-----------|------|
| **Hostile**（敌对） | ≤-75 | 袭击、攻击、无法贸易 |
| **Neutral**（中立） | -74 ~ +74 | 可贸易、可通行 |
| **Ally**（盟友） | ≥+75 | 可请求军事援助 |

**好感度变化来源**：

| 来源 | 变化量 | 方向 |
|------|--------|------|
| 伤害成员 | -1.3×伤害量 | 负 |
| 杀死成员 | -20~-40 | 负 |
| 囚禁成员 | 好感度上限锁-100 | 负（情境） |
| 贸易 | +市场价值/600 | 正 |
| 释放俘虏 | +12/人 | 正 |
| 赠送礼物 | +市场价值/40 | 正 |
| 完成任务 | +10~+40 | 正 |

**自然好感度回归**：`CheckReachNaturalGoodwill()`每3,000,000 ticks（≈50天）执行，向自然值漂移±10。自然值由`GoodwillSituationManager`计算（基础0 + 情境偏移之和）。

> **要点**：
> 1. 阈值是-75和+75（不是±100），中立范围很宽
> 2. 释放俘虏（+12/人）是最高效的好感度恢复手段
> 3. `permanentEnemy`派系好感度锁定-100，`TryAffectGoodwillWith()`直接拒绝变化

📖 [派系关系与好感度系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\派系关系与好感度系统.md)

#### 3. 派系Pawn特征与生成机制

派系Pawn的特征由三层架构决定：`FactionDef`（派系级约束：maxPawnCostPerTotalPointsCurve、xenotypeSet、backstoryFilters）→ `PawnGroupMaker`（场景级组合：kindDef类型+options权重映射+commonality选择权重）→ `PawnKindDef`（个体级定义：combatPower、weaponMoney/apparelMoney装备预算、weaponTags/apparelTags装备筛选、itemQuality品质、skills技能、techHediffs植入体）。

**各派系代表性PawnKindDef核心参数对比**：

| 维度 | 部落战士 | 城镇守卫 | 佣兵枪手 | 精英佣兵 | 帝国士兵 |
|------|---------|---------|---------|---------|---------|
| **combatPower** | 50 | 60 | 85 | 130 | 65 |
| **weaponMoney** | 150 | 250~400 | 330~650 | 500~1400 | 1100~2500 |
| **apparelMoney** | 200~300 | 400~600 | 1000~1500 | 2500~3500 | 5000~8000 |
| **itemQuality** | Poor | Normal | Normal | Normal | Normal |
| **techHediffsChance** | 无 | 4% | 15% | 35% | 30% |
| **特殊要求** | — | — | — | 80%战斗药物 | DeathAcidifier必须, 25% Hussar |

**PawnGroupMaker战术组合**：同一派系通过多个Combat PawnGroupMaker实现战术多样性。海盗拥有6个Combat组（混合100/纯近战30/纯远程20/爆破15/纯狙击10/纯流浪者2.5），部落拥有4个Combat组（混合100/纯远程60/纯近战60/破墙5）。`commonality`权重控制各战术的出现概率。

**点数预算分配**：`ChoosePawnGenOptionsByPoints()`在总点数预算内迭代加权随机选取PawnKindDef。`MaxPawnCost()`通过`maxPawnCostPerTotalPointsCurve`限制单个Pawn最大点数（低点数时≤35~50，防止低威胁袭击出现精英单位）。权重修正曲线倾向选择便宜的PawnKind填充数量。

**装备生成**：`PawnWeaponGenerator`/`PawnApparelGenerator`采用"标签+预算"双重过滤——weaponTags/apparelTags决定能选什么类型，weaponMoney/apparelMoney决定选多贵的等级。`apparelRequired`和`techHediffsRequired`强制指定必须装备。

> **要点**：
> 1. 装备预算差距巨大——部落战士weaponMoney仅150，帝国士兵高达1100~2500，相差7~17倍
> 2. 帝国士兵是唯一强制DeathAcidifier的PawnKind——死后尸体酸化防止装备被掠夺
> 3. 模组设计自定义派系时，PawnKindDef层级（3~5级）+ 多个Combat PawnGroupMaker（3~6个）是标准模式

📖 [派系Pawn特征与生成机制](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\派系Pawn特征与生成机制.md)

#### 4. 模组自定义派系与扩展模式

社区模组通过4种扩展模式自定义派系：纯XML定义 → XML+DefModExtension(VEF) → XML+自定义WorldObjectComp → 完整派系子系统。

**3个代表性模组速查**：

| 模组 | 派系数 | 扩展模式 | 核心机制 |
|------|--------|---------|---------|
| **NCL/TW（机械族全面战争）** | 2（友方+敌方） | 纯XML + CompTameableMech | 双派系友敌分离，hidden+raidsForbidden，驯服系统Gizmo→Job→SetFaction(50%成功率) |
| **GD5（闪耀毁灭者5）** | 1（BlackMechanoid） | 纯XML + MissionComponent | permanentEnemyToEveryoneExceptPlayer，earliestRaidDays=999999，全部交互通过QuestScriptDef |
| **Milira（米莉拉）** | 3（天空精灵+天羽教会+玩家） | 完整子系统 | permanentEnemyToEveryoneExcept，16个Combat组，WorldObjectCompMiliraSettlement定居点交互，royalTitleTags头衔体系 |

**VEF FactionDefExtension**：社区事实标准扩展框架，15+字段覆盖生物群系限制（allowedBiomes/disallowedBiomes）、初始好感度预设（startingGoodwillByFactionDefs）、功能控制（excludeFromCommConsole/excludeFromQuests）、定居点生成控制（minDistanceToOtherSettlements）。

> **要点**：
> 1. 模组派系最强大的能力是**动态关系转换**——原版permanentEnemy锁死-100，模组通过WorldObjectComp+CheckPermanentEnemyStatus()实现条件触发的敌→中立转换
> 2. `earliestRaidDays=999999`是"任务驱动派系"的标准做法——禁止Storyteller自动调度袭击，所有交互通过QuestScriptDef控制
> 3. Milira的16个Combat PawnGroupMaker展示了大型派系的战术多样性设计——远超原版海盗6组/部落4组

📖 [模组自定义派系与扩展模式](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\模组自定义派系与扩展模式.md)

#### 5. 派系与袭击的关系

每次敌对袭击（`IncidentWorker_RaidEnemy`）通过`TryResolveRaidFaction()`选择袭击派系，使用`FactionCanBeGroupSource()`过滤+`raidCommonalityFromPointsCurve`加权随机。

**袭击派系选择条件**：

| # | 条件 | 说明 |
|---|------|------|
| 1 | `HostileTo(Player)` | 必须对玩家敌对 |
| 2 | `!deactivated` | 派系未停用 |
| 3 | `DaysPassedSinceSettle ≥ earliestRaidDays` | 满足最早袭击天数 |
| 4 | `raidsForbidden != true` | 未禁止袭击 |
| 5 | 至少一个RaidStrategy可用 | 有可用袭击策略 |

**各派系raidCommonality对比**：

| 派系 | 300点 | 700点 | 1400点 | 4000点 | 说明 |
|------|-------|-------|--------|--------|------|
| TribeBase | 1.0 | 1.0 | 1.0 | 1.0 | 恒定 |
| Pirate | 1.0 | 1.0 | 1.0 | 1.0 | 恒定 |
| Empire | 1.0 | 1.0 | 1.0 | 1.0 | 恒定 |
| **Mechanoid** | **0** | **1.0** | **1.8** | **2.6** | 300点以下不袭击，后期权重递增 |
| Insect | 0 | 0 | 0 | 0 | 不通过常规袭击（虫巢独立事件） |

**非标准袭击来源**（不走RaidEnemy流程）：虫巢（Insect）、机械族集群（Mechanoid, Royalty）、灵能仪式围攻（HoraxCult, Anomaly）、异常实体（Entities, 各种专属事件）、深渊之门（Entities, Anomaly）。

> **要点**：
> 1. `raidsForbidden=true`只禁止常规袭击——HoraxCult通过灵能仪式围攻，虫族通过虫巢事件
> 2. 机械族`earliestRaidDays=45`+曲线300点起步=游戏早期不会遇到机械族袭击
> 3. 模组自定义派系必须配置`pawnGroupMakers`（至少一个Combat组）和`raidCommonalityFromPointsCurve`才能作为袭击来源

📖 [派系与袭击关系](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\派系与袭击关系.md)

---

## 第8章 事件与袭击系统 ★★☆

> **对应模组需求**：门/Gate（实体14）、R33门生成袭击（自定义RaidWorker）、R35死亡事件生成黑触发器

### 引导问题

1. 游戏事件有哪些大类？（袭击、贸易、天气、随机事件……）
2. 袭击的流程是怎样的？（触发条件→生成敌人→进攻方式→结束条件）
3. 你见过哪些不同的袭击方式？（正面进攻、空投、围攻、虫巢……）
4. 事件的触发机制是什么？（叙事者、威胁点数、冷却时间……）
5. 你见过模组自定义的事件吗？它们怎么融入原版的事件系统？
6. 死亡事件会触发什么后续效果？（心情debuff、社交影响、物品掉落……）

### 你的笔记

#### 1. 游戏事件大类

三层架构：`IncidentDef`（定义层）→ `IncidentWorker`（执行层，60+子类）→ `Storyteller` + `StorytellerComp`（调度层，21个Comp子类）。每1000 ticks调度一次。

13个IncidentCategoryDef归纳为6大功能类别：

| # | 功能类别 | 包含的Category | 典型事件 |
|---|---------|---------------|---------|
| 1 | **威胁类** | ThreatBig, ThreatSmall | 袭击、虫巢、机械集群 |
| 2 | **杂项类** | Misc | 资源舱坠落、流浪者加入 |
| 3 | **派系/贸易类** | FactionArrival, OrbitalVisitor | 贸易商队、轨道贸易商 |
| 4 | **疾病类** | DiseaseHuman, DiseaseAnimal | 流感、瘟疫 |
| 5 | **任务类** | GiveQuest, EndGame | 各种QuestScriptDef任务 |
| 6 | **特殊类** | Special, ShipChunkDrop | 飞船碎片、深钻虫巢 |

> **要点**：
> 1. 模组自定义事件只需两步：IncidentDef（XML）+ IncidentWorker子类（C#），重写`CanFireNowSub()`和`TryExecuteWorker()`

📖 [事件系统大类与触发架构](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\事件系统大类与触发架构.md)

#### 2. 袭击完整流程

袭击由`IncidentWorker_RaidEnemy`驱动，10步流程：

```
Storyteller选择RaidEnemy事件
  → TryGenerateRaidInfo(parms, out pawns)
    ├── ①ResolveRaidPoints          ← 解析威胁点数
    ├── ②TryResolveRaidFaction      ← 选择敌对派系（加权随机）
    ├── ③ResolveRaidStrategy        ← 选择袭击策略（按点数权重）
    ├── ④TryResolveRaidArriveMode   ← 选择到达模式
    ├── ⑤ResolveRaidAgeRestriction  ← 年龄限制(Biotech)
    ├── ⑥TryGenerateThreats        ← 策略特定威胁
    ├── ⑦TryResolveRaidSpawnCenter  ← 确定生成位置
    ├── ⑧AdjustedRaidPoints        ← 多层点数调整
    ├── ⑨GeneratePawns/SpawnThreats ← 生成袭击者
    └── ⑩PostProcessSpawnedPawns    ← 后处理
  → GenerateRaidLoot → SendStandardLetter → MakeLords
```

> **要点**：
> 1. Lord状态机是袭击行为的核心——所有袭击者行为由LordJob的StateGraph驱动

📖 [袭击流程与结束条件](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\袭击流程与结束条件.md)

#### 3. 不同袭击方式

10个RaidStrategyDef（决定"怎么打"）：

| # | defName | 行为描述 | 关键特征 | DLC |
|---|---------|---------|---------|-----|
| 1 | **ImmediateAttack** | 直接攻击 | 最基础，权重恒定1.0 | Core |
| 2 | **ImmediateAttackSmart** | 智能攻击 | 避开陷阱/炮塔，≥1000点 | Core |
| 3 | **ImmediateAttackSappers** | 工兵攻击 | 挖掘绕过防御，≥700点 | Core |
| 4 | **ImmediateAttackBreaching** | 破坏攻击 | 炸墙进入，≥700点 | Core |
| 5 | **ImmediateAttackBreachingSmart** | 智能破坏 | 破坏+避障，≥700点 | Core |
| 6 | **StageThenAttack** | 集结后攻击 | 先集结再统一进攻 | Core |
| 7 | **Siege** | 围攻 | 建炮台远程轰击，minPawns=4 | Core |
| 8 | **EmergeFromWater** | 水中出现 | 仅机械族 | Core |
| 9 | **PsychicRitualSiege** | 心灵仪式围攻 | Horax邪教徒 | Anomaly |
| 10 | **ShamblerAssault** | 蹒跚者突击 | 僵尸分散逼近 | Anomaly |

13个PawnsArrivalModeDef（决定"怎么来"）和策略×到达模式兼容矩阵详见参考文档。

> **要点**：
> 1. 自定义袭击策略XML很简单——配置`workerClass`、`arriveModes`、`selectionWeightPerPointsCurve`即可
> 2. `selectionWeightPerPointsCurve`控制策略出现时机——工兵/破坏/围攻都有最低点数阈值

📖 [袭击策略与到达模式](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\袭击策略与到达模式.md)

#### 4. 事件触发机制

三大叙事者核心调度对比：

| 维度 | Cassandra | Randy | Phoebe |
|------|-----------|-------|--------|
| **威胁调度** | OnOffCycle | RandomMain | OnOffCycle |
| **ThreatBig周期** | 4.6天开/6天关 | MTB 1.35天 | 8天开/8天关 |
| **最早触发天** | 11天 | 1天 | 13天 |
| **类别选择** | 固定ThreatBig/Small | categoryWeights加权随机 | 固定ThreatBig/Small |

威胁点数 = (财富点数 + Pawn点数) × 随机因子 × 适应因子 × threatScale × 天数因子，详细公式和适应系统见参考文档。

> **要点**：
> 1. Cassandra/Phoebe用OnOffCycle（可预测节奏），Randy用RandomMain（完全随机）
> 2. 适应系统是动态难度核心——殖民者死亡大幅降低威胁，长期顺风则增加威胁

📖 [事件触发机制与叙事者系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\事件触发机制与叙事者系统.md)

#### 5. 模组自定义事件

标准流程（2步）：XML定义IncidentDef + C#实现IncidentWorker子类。

4种融入方式：

| # | 方式 | 适用场景 |
|---|------|---------|
| 1 | **标准IncidentDef** | 融入Storyteller随机池 |
| 2 | **自定义StorytellerComp** | 需要独立调度逻辑 |
| 3 | **建筑/实体触发** | 事件由游戏内实体触发 |
| 4 | **DefModExtension** | 为IncidentDef附加自定义数据 |

> **要点**：
> 1. PitGate是"门生成袭击"的最佳参考——IncidentWorker生成建筑，建筑在自身逻辑中生成敌人，完美解耦
> 2. category决定调度方式——选错category会导致事件触发频率不符预期

📖 [事件触发机制与叙事者系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\事件触发机制与叙事者系统.md)

#### 6. 死亡事件后续效果

Pawn死亡由`Pawn.Kill()`驱动，6阶段流程触发7大核心系统（健康、心情、关系、派系、任务、叙事、物品），30+个Notify回调。按功能分6大效果类别：

| # | 效果类别 | 核心系统 | 关键方法 |
|---|---------|---------|---------|
| 1 | **心情Debuff** | PawnDiedOrDownedThoughtsUtility | TryGiveThoughts()：5大类心情（目击/知晓/家庭/社交/杀手） |
| 2 | **关系影响** | Pawn_RelationsTracker | Notify_PawnKilled()：配偶心情移除、关系清理、绑定动物行为变化 |
| 3 | **物品掉落** | Pawn | DropAndForbidEverything()：装备掉落/销毁 + MakeCorpse()尸体生成 + 腐烂判定 |
| 4 | **死亡动作** | DeathActionWorker | PawnDied()：6个子类（Simple/SmallExplosion/BigExplosion/ToxCloud/Vanish/Divide） |
| 5 | **叙事/派系/任务** | Storyteller + Faction + QuestManager | 适应系统降低adaptDays、派系好感变化、任务失败/更新 |
| 6 | **DLC效果** | Anomaly/Biotech/Royalty/Ideology | 突变体/基因/皇室/意识形态各自通知 |

心情Debuff强度梯度：配偶死亡(-20) > 子女(-20) > 恋人(-16) > 兄弟姐妹(-14) > 好友(-10) > 父母(-8) > 绑定动物(-8) > 目击同盟(-5) > 知晓殖民者死亡(-3)。

> **要点**：
> 1. **DeathActionWorker是模组扩展死亡效果的最干净路径**——继承基类重写`PawnDied()`，XML配置`deathActionWorkerClass`，无侵入无兼容风险
> 2. **心情系统有豁免机制**——Psychopath/Bloodlust特性豁免大部分死亡debuff，有罪Pawn死亡不触发全殖民者心情

📖 [死亡事件后续效果链](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\死亡事件后续效果链.md)

---

## 第9章 机械体与人工单位 ★★☆

> **对应模组需求**：Trion兵（实体8）、近界民（实体9）、R19制造设施制造Trion兵、R21近界民操控Trion兵

### 引导问题

1. 原版机械族（Mechanoid）有哪些单位？它们的特点是什么？
2. Biotech DLC的机械师系统是怎么工作的？（召唤、控制、带宽……）
3. 机械体和普通Pawn有什么区别？（需求、健康、行为……）
4. 你见过模组自定义的机械体或人工单位吗？
5. 敌对派系的Pawn和玩家的Pawn在系统层面有什么不同？

### 你的笔记

#### 1. 原版机械族单位总览

原版共约25个机械族单位，分布在3个DLC中——Core 7个（机械蜈蚣×3 + 机械静螳 + 机械飞螳 + 机械蝎蝽 + 机械白蚁）、Biotech 17个（5工人 + 4轻型战斗 + 2中型 + 1重型 + 4超重型Boss）、Odyssey 1个（机械炬瞳）。所有机械体共享`BaseMechanoid`抽象ThingDef，核心特征：`fleshType=Mechanoid`（非有机体）、无食物/休息需求、免疫毒素和极端温度。通过4级`MechWeightClassDef`（Light/Medium/Heavy/UltraHeavy）分类。

**按重量级×功能分类速查**：

| 重量级 | 战斗型 | 工人型 | 支援型 | Boss型 |
|--------|--------|--------|--------|--------|
| **Light** | 机械辅兵, 战争爪牙, 机械炽蚕 | 搬运机, 建造机, 工艺机, 园艺机, 清洁机 | 救护机 | — |
| **Medium** | 机械静螳, 机械飞螳, 机械蝎蝽, 机械白蚁, 机械哨卫, 机械炬瞳 | — | 机械盾卫(弹幕盾) | — |
| **Heavy** | 机械蜈蚣×3 | — | 掘进机(采矿+盾) | — |
| **UltraHeavy** | — | — | 百机长(弹幕盾) | 憎恶毒蜂(复活), 炼狱魔王(地狱球), 战争女皇(载体) |

> **要点**：
> 1. **创建自定义机械体只需ThingDef+PawnKindDef**——继承`BaseMechanoid`抽象模板，设置`mechWeightClass`/`body`/`combatPower`等字段，通过Comp添加特殊行为（护盾、载体、炮塔），工人型额外设置`mechEnabledWorkTypes`
> 2. **UltraHeavy不可复活**——`MechWeightClassDef.canResurrect=false`是Boss机制的核心限制

📖 [原版机械族单位总览](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\原版机械族单位总览.md)

#### 2. 机械师系统（Biotech DLC）

机械师系统围绕"带宽容量/占用"模型运作：机械师拥有带宽上限（Stat累加），每个机械体占用一定带宽，超出则断开连接并可能野化。

**核心架构**：`Hediff_Mechlink`（脑部植入体，激活条件）→ `Pawn_MechanitorTracker`（核心逻辑）→ 3类Gizmo（UI呈现）。监管关系通过`PawnRelationDefOf.Overseer`建立。

**带宽系统**：

| 维度 | 来源 | 实现方式 |
|------|------|---------|
| **容量** | Mechlink(+6) + 装备(+3~15) + BandNode建筑(每个+1) | 全部通过`StatDefOf.MechBandwidth`叠加 |
| **占用** | 已监管机械体(BandwidthCost) + 孵化中机械体(Bill预占) | `UsedBandwidthFromSubjects + UsedBandwidthFromGestation` |

**控制组系统**：每组独立设置工作模式（Work/Escort/Recharge/SelfShutdown）和目标。容量由`StatDefOf.MechControlGroups`决定，基础2组，Sublink植入体最多+6组。

**失控机制**：超带宽/机械师倒下 → `Notify_DisconnectedFromOverseer()`断开 → 取消征召+中断Job → 延迟后按MTB概率野化为敌对。

**Gizmo UI**：带宽方块网格（三色：已用/空闲/超额）+ Boss组召唤按钮 + 每组一个控制组面板（成员图标+工作模式切换）+ 全选按钮。

**命令范围**：征召机械体必须在机械师24.9格内才能接受命令。

> **要点**：
> 1. 带宽是纯Stat系统——植入体/装备/建筑通过statOffsets/equippedStatOffsets/动态HediffStage三条路径叠加，无需自定义计算逻辑
> 2. 失控机制是"软惩罚"设计——不是立即失控，而是延迟+MTB概率，给玩家反应时间

📖 [机械师系统与带宽控制体系](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\机械师系统与带宽控制体系.md)

#### 3. 机械体与普通Pawn的区别

机械体（`IsMechanoid`）与有机体Pawn在10个维度存在系统级差异，核心分界线是`FleshTypeDef.isOrganic`（机械体=false）。代码中有60+处`IsMechanoid`检查点。

**核心差异对比**：

| # | 维度 | 有机体Pawn | 机械体Pawn |
|---|------|-----------|-----------|
| 1 | **FleshType** | Normal（isOrganic=true） | Mechanoid（isOrganic=false） |
| 2 | **需求** | Food/Rest/Joy/Mood等18种 | 仅MechEnergy（玩家机械体） |
| 3 | **健康** | 医疗治疗、感染风险、出血 | 机械修复（CompMechRepairable）、无感染/出血 |
| 4 | **倒地即死** | 玩家0%，非玩家按曲线 | 非玩家100% |
| 5 | **行为/AI** | Humanlike ThinkTree | Mechanoid ThinkTree + 工作模式 |
| 6 | **眩晕** | NerveStun✅ EMP❌ | EMP✅ NerveStun❌ |
| 7 | **社交/基因** | 完整社交+基因系统 | 无（缺失skills/story/genes/relations等12个Tracker） |
| 8 | **技能** | 20个技能，可升级 | 固定等级（mechFixedSkillLevel=10） |
| 9 | **渲染** | 头发/头型/服装/呼吸特效 | 无头发/无呼吸/LifeStage贴图 |
| 10 | **精神状态** | 多种MentalState | 仅BerserkMechanoid |

**Pawn组件初始化**（`PawnComponentsUtility.CreateInitialComponents`）：
- 所有Pawn共有：health, needs, jobs, stances等13个
- ToolUser条件（机械体✅）：equipment, apparel
- Humanlike条件（机械体❌）：skills, story, guest, genes, workSettings等12个
- IsFlesh条件（机械体❌）：relations, psychicEntropy
- 动态添加（玩家机械体）：drafter, relations, workSettings

> **要点**：
> 1. 机械体的系统差异是"减法设计"——从完整Pawn中移除社交/基因/心情/感染等子系统，保留战斗/工作/装备核心
> 2. 玩家机械体通过`AddAndRemoveDynamicComponents`动态获得drafter/relations/workSettings，实现"可控"

📖 [机械体与普通Pawn系统差异](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\机械体与普通Pawn系统差异.md)

#### 4. 模组自定义机械体与人工单位

社区模组通过4种扩展模式自定义机械体——纯XML继承、自定义Comp、自定义Verb+PawnFlyer、完整子系统。3个代表性模组展示了从简单数值修改到复杂系统协作的完整技术谱系。

**3个代表性模组速查表**：

| 模组 | 单位数 | 核心特色 | 技术路径 | 独立派系 |
|------|--------|---------|---------|---------|
| **米莉拉(Milira)** | ~15 | 棋子主题+晋升系统+自定义PawnFlyer | Comp+Hediff+自定义Thing | ✅ Milira_Faction |
| **闪耀毁灭者5(GD5)** | ~5 | 黑色强化变体+隐身+辅助瞄准 | XML继承+自定义Comp | ❌（原版机械族） |
| **机械族全面战争(NCL/TW)** | 20+ | 大规模单位库+驯服+贸易+自动恢复 | Comp+Job+Harmony补丁 | ✅ NCL_faction |

**4种扩展模式对比表**：

| 模式 | 需要C# | 复杂度 | 适用场景 | 典型实例 |
|------|--------|--------|---------|---------|
| **纯XML继承** | 否 | 低 | 改数值/外观/武器 | GD5 BlackMilitor(HP25000) |
| **自定义Comp** | 是 | 中 | 单一新行为 | GD5隐身/NCL自动恢复 |
| **自定义Verb+PawnFlyer** | 是 | 中~高 | 新攻击/位移方式 | Milira 5种冲锋攻击 |
| **完整子系统** | 是 | 高 | 跨系统协作 | Milira晋升/NCL驯服+贸易 |

**关键自定义Comp汇总表**（按功能分类）：

| 功能类 | Comp | 模组 | 核心机制 |
|--------|------|------|----------|
| **控制** | CompObserverLink | GD5 | 选择目标→Hediff增益→距离衰减 |
| **控制** | CompClassAmplificationLoop | Milira | King周期性维持周围单位职阶 |
| **防护** | CompMechanoidShield | NCL | 反射重激活+解除倒地 |
| **防护** | CompPawnInvisibility | GD5 | 区域隐身Hediff发射器 |
| **攻击** | MiliraPawnFlyer系列 | Milira | 5种自定义冲锋/跳跃攻击 |
| **生成** | Comp_SpawnPawnsOnDestroy | NCL | 死亡时生成子单位 |
| **生成** | CompSendPromotionRequest | Milira | 死亡时触发附近单位晋升 |
| **贸易** | Comp_MechEmployable | NCL | 机械体贸易标记+自定义Tradeable |

> **要点**：
> 1. 自定义机械体的核心是**继承链设计**——用抽象模板统一共性（BaseMechanoid→自定义抽象→具体单位），用Comp附加个性化行为
> 2. "死亡触发"是机械体特有的设计空间——Milira的晋升请求和NCL的子单位生成都利用PostDestroy()实现"阵亡→队友强化/补充"

📖 [模组自定义机械体与人工单位](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\模组自定义机械体与人工单位.md)

#### 5. 敌对派系与玩家Pawn的系统差异

同一种族的Pawn因所属派系不同，在8个维度存在运行时差异。核心判定：`pawn.Faction.IsPlayer`和`pawn.IsColonist`。

**核心差异对比**：

| # | 维度 | 玩家Pawn | 敌对派系Pawn |
|---|------|---------|------------|
| 1 | **倒地即死** | 0%（永不触发） | 人形：人口意图曲线×难度系数；机械体：100% |
| 2 | **即死保护** | ✅（仅IsColonist，7次迭代削减） | ❌ |
| 3 | **Pawn组件** | 完整（+outfits/drugs/drafter等6组件） | 精简（无outfits/drugs/timetable/drafter） |
| 4 | **AI/行为** | 玩家命令驱动（DraftedOrder） | Lord/Duty状态机驱动 |
| 5 | **装备掉落** | 正常掉落 | 自动Forbid（`HostileTo(OfPlayer)`） |
| 6 | **医疗** | 自动治疗 | 默认不治疗（需俘虏后设置playerSettings） |
| 7 | **Storyteller** | 死亡降低适应系数（减少威胁） | 死亡不影响适应系数 |
| 8 | **战斗AI** | 不自动使用手动武器 | 自动使用所有武器（`allowManualCastWeapons=true`） |

**倒地即死概率速查**：

| Pawn类型 | DoD概率 |
|---------|--------|
| 玩家殖民者/机械体 | 0%（跳过判定） |
| 非玩家机械体 | 100% |
| 非玩家动物 | 50% |
| 非玩家人形 | ~26%-80%（按人口意图动态调节） |
| 变异体（Shambler/Ghoul） | 25% |

> **要点**：
> 1. 派系差异是"运行时"的——同一Pawn改变派系后，`AddAndRemoveDynamicComponents`自动调整组件，DoD概率随之改变
> 2. DoD系统是RimWorld的"隐形人口调节器"——模组自定义敌方单位可通过`PawnKindDef.overrideDeathOnDownedChance`精确控制

📖 [敌对派系与玩家Pawn系统差异](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\敌对派系与玩家Pawn系统差异.md)

---

## 第10章 建筑与工作台 ★☆☆

> **对应模组需求**：制造设施（实体10）、母触发器/星触发器（实体11）、R19制造设施制造Trion兵

### 引导问题

1. 工作台的基本工作流程是什么？（选择配方→分配工作→消耗材料→产出物品）
2. 配方（Recipe）系统你了解多少？（材料需求、技能需求、产出……）
3. 建筑有哪些类型？（工作台、存储、防御、装饰、电力……）
4. 建筑的供电系统是怎么工作的？
5. 你见过模组自定义的工作台吗？它们有什么特殊功能？

### 你的笔记

#### 1. 工作台基本工作流程

工作台（`Building_WorkTable`）实现`IBillGiver`接口，完整工作流程经过6个阶段，涉及7个核心类协作：

```
玩家UI层          数据层              调度层                执行层              产出层
──────────       ──────────         ──────────           ──────────         ──────────
ITab_Bills  →  BillStack/Bill  →  WorkGiver_DoBill  →  JobDriver_DoBill  →  GenRecipe
(添加配方)     (配方队列)         (扫描+找材料)        (搬运+制造)          (生成产品)
```

**6阶段流程**：①玩家通过ITab_Bills添加Bill（配方实例） → ②`WorkGiver_DoBill`扫描工作台BillStack，检查`ShouldDoNow()`+技能+材料 → ③`TryFindBestBillIngredients()`按距离排序搜索材料（两种模式：NoMix默认/AllowMix烹饪） → ④生成DoBill Job → ⑤`JobDriver_DoBill`执行7步Toil序列（搬运材料→前往工作台→制造→完成） → ⑥`GenRecipe.MakeRecipeProducts()`生成产品+品质判定+按BillStoreMode入库。

**Bill三子类**：`Bill_Production`（标准生产）→ `Bill_ProductionWithUft`（长工期，含UnfinishedThing）→ `Bill_Mech`（机械体孵化）；`Bill_Medical`（手术）；`Bill_Autonomous`（自主运行）。

**三种重复模式**：RepeatCount（指定次数，默认）、Forever（无限制）、TargetCount（维持库存数量）。

**三种存储模式**：DropOnFloor（丢地上）、BestStockpile（最佳储存区）、SpecificStockpile（指定储存区）。

**工作速度公式**：`workLeft -= pawn.workSpeedStat × workTable.workTableSpeedStat × delta`，workLeft降至0时完成。

> **要点**：
> 1. 模组新增工作台只需XML继承`BenchBase`——自动获得ITab_Bills配方系统+BillStack+WorkGiver_DoBill调度
> 2. `unpoweredWorkTableWorkSpeedFactor > 0`允许工作台断电时以降低速度工作，而非完全停止

📖 [工作台基本工作流程](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\工作台基本工作流程.md)

#### 2. 配方（Recipe）系统

`RecipeDef`是生产和手术系统的核心定义，80+字段分8大类。配方分两大类：**生产配方**（工作台制造物品）和**手术配方**（Pawn身上执行手术）。

**配方与工作台双向绑定**：`RecipeDef.recipeUsers`（配方声明可用工作台）和`ThingDef.recipes`（工作台声明支持配方）两条路径等效，运行时合并。

**材料需求三层过滤**：`fixedIngredientFilter`（不可变硬限制）→ `defaultIngredientFilter`（默认启用子集）→ `Bill.ingredientFilter`（玩家可调）。每个`IngredientCount`包含ThingFilter+count，计量方式由`ingredientValueGetterClass`决定——`Volume`（默认，按个数）或`Nutrition`（按营养值，烹饪用）。

**产出两种类型**：`products`（标准产出，`List<ThingDefCountClass>`，数量受efficiency影响）和`specialProducts`（特殊产出，Butchery屠宰/Smelted熔炼，从材料动态生成）。

**RecipeWorker体系**：基类`RecipeWorker`（通用配方）→ `Recipe_Surgery`（手术基类，10+子类覆盖安装植入体/截肢/给药/处决等）。手术专用字段：`appliedOnFixedBodyParts`、`addsHediff`、`removesHediff`、`surgerySuccessChanceFactor`、`deathOnFailedSurgeryChance`。

**可用性5层条件链**：researchPrerequisite → memePrerequisitesAny → researchPrerequisites → factionPrerequisiteTags → fromIdeoBuildingPreceptOnly。

| 维度 | 制造配方 | 烹饪配方 | 手术配方 |
|------|---------|---------|---------|
| workerClass | RecipeWorker（默认） | RecipeWorker（默认） | Recipe_Surgery子类 |
| ingredientValueGetter | Volume（按个数） | Nutrition（按营养值） | Volume |
| allowMixingIngredients | false | true | false |
| requiredGiverWorkType | null/Crafting/Smithing | Cooking | null |
| 产出方式 | products | products | addsHediff/removesHediff |

> **要点**：
> 1. 绝大多数模组配方只需纯XML定义——RecipeDef字段覆盖标准制造和手术场景，只有非标准产出逻辑才需自定义RecipeWorker
> 2. `requiredGiverWorkType`限制的是殖民者而非工作台——同一工作台上的不同配方可要求不同WorkType的殖民者

📖 [配方系统与RecipeDef体系](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\配方系统与RecipeDef体系.md)

#### 3. 建筑类型分类

RimWorld的建筑分类采用**双层体系**——`DesignationCategoryDef`定义建筑师菜单中的玩家可见分类（共16个：Core 12 + DLC 4），`Building` C#类继承树定义引擎行为（60+子类）。两者独立运作：菜单归属由XML中`designationCategory`字段指定，运行时行为由`thingClass`指定的C#类决定。大多数建筑直接使用`Building`基类，通过Comp组件组合实现功能差异。

**表1：DesignationCategoryDef完整列表（16个，按order降序）**

| defName | label | order | 来源 | 典型建筑 | 说明 |
|---------|-------|-------|------|---------|------|
| `Orders` | orders | 900 | Core | —（纯指令） | 取消/拆除/采矿/砍伐等18个指令 |
| `Zone` | zone | 800 | Core | —（纯区域） | 储存区/种植区/家园区等 |
| `Structure` | structure | 700 | Core | 墙壁、门、柱子 | 结构建筑 |
| `Production` | production | 600 | Core | 电炉、裁缝台 | 工作台核心分类 |
| `Furniture` | furniture | 500 | Core | 床、桌椅、灯 | 最大的建筑分类 |
| `Power` | power | 400 | Core | 发电机、电池、电线 | 需研究Electricity |
| `Security` | security | 300 | Core | 炮塔、沙袋、陷阱 | 防御建筑 |
| `Misc` | misc | 250 | Core | 通讯台、坟墓 | 杂项 |
| `Floors` | floors | 200 | Core | 各种地板 | 含地板特殊指令 |
| `Joy` | recreation | 100 | Core | 台球桌、电视 | 娱乐设施 |
| `Ship` | ship | 50 | Core | 飞船部件 | 需研究ShipBasics |
| `Temperature` | temperature | 25 | Core | 加热器、冷却器 | 温控设施 |
| `Ideology` | ideology | 13 | Ideology | 祭坛、火炬柱 | 意识形态建筑 |
| `Biotech` | biotech | 12 | Biotech | 机械孵化器 | 需研究Electricity |
| `Anomaly` | anomaly | 11 | Anomaly | 拘留平台 | 需minMonolithLevel≥1 |
| `Odyssey` | odyssey | 10 | Odyssey | 奥德赛建筑 | — |

**表2：Building C#类按功能分8大类**

| 功能分类 | 核心C#类 | 典型建筑 | 关键Comp/特性 |
|---------|---------|---------|-------------|
| 生产/工作 | `Building_WorkTable`, `Building_ResearchBench` | 电炉、研究台 | ITab_Bills配方系统 |
| 存储/容器 | `Building_Storage`, `Building_Casket` | 货架、休眠舱 | StorageSettings |
| 家具/床 | `Building_Bed`, `Building_Art` | 床、雕塑 | bed_*字段、CompQuality |
| 安防/陷阱 | `Building_TurretGun`, `Building_Trap` | 炮塔、尖刺陷阱 | turretGunDef、isTrap |
| 电力 | `Building_Battery`, `Building_PowerSwitch` | 电池、开关 | CompPowerTrader |
| 温控 | `Building_TempControl` | 加热器、冷却器 | 温度目标设定 |
| 可进入 | `Building_Enterable`→GrowthVat/GeneExtractor | 成长舱、基因提取器 | Pawn进入→处理→退出 |
| 特殊/自然 | `Building_Door`, `Mineable`, `MapPortal` | 门、矿脉、传送门 | 各自独立逻辑 |

**表3：建筑常用Comp速查（8个核心Comp）**

| Comp | 功能 | 典型使用者 |
|------|------|-----------|
| `CompPowerTrader` | 消耗/产生电力 | 工作台、炮塔、灯 |
| `CompRefuelable` | 燃料消耗 | 火把、火炉、发电机 |
| `CompFlickable` | 开关控制 | 灯、加热器、炮塔 |
| `CompBreakdownable` | 故障系统 | 工作台、炮塔、发电机 |
| `CompFacility` | 作为设施提供加成 | 工具柜→工作台 |
| `CompAffectedByFacilities` | 接收设施加成 | 工作台、医疗床 |
| `CompHeatPusher` | 向房间推送热量 | 火把、熔炉 |
| `CompGlower` | 发光照明 | 灯、火把、日光灯 |

> **要点**：
> 1. 模组新增建筑只需ThingDef(XML) + `designationCategory`指定菜单分类，大多数不需要自定义C#类——通过Comp组合即可实现功能
> 2. `BenchBase`是工作台的标准抽象模板——继承它自动获得配方系统(ITab_Bills)+工作速度报告+Production标签
> 3. 建筑的功能主要由Comp组件决定，而非C#子类。典型电力工作台 = `CompPowerTrader`+`CompFlickable`+`CompBreakdownable`+`CompAffectedByFacilities`

📖 [建筑类型分类与DesignationCategory体系](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\建筑类型分类与DesignationCategory体系.md)

#### 4. 建筑供电系统

电力系统采用四层架构：`CompPower`组件层 → `PowerNet`电网层 → `PowerNetManager`管理层 → `PowerNetGrid`网格层。电力以"瓦特日"（Wd）为存储单位，负值basePowerConsumption表示产出。

**CompPower类继承体系**：

| 层级 | 类 | 职责 | 典型建筑 |
|------|---|------|---------|
| **传输** | `CompPowerTransmitter` | 构成电网骨架（BFS连通） | 电线、墙内电线、电源开关 |
| **存储** | `CompPowerBattery` | 充放电，效率50% | 电池 |
| **交易** | `CompPowerTrader` | 消费或生产电力 | 工作台、炮塔、灯 |
| **发电** | `CompPowerPlant`（→7子类） | 发电厂基类，条件检查链 | 太阳能、风力、地热等 |

**原版发电建筑速查**：

| 建筑 | 功率 | CompClass | 特殊条件 | DLC |
|------|------|-----------|---------|-----|
| 木柴发电机 | -1000W | CompPowerPlant | 木材22/天 | Core |
| 化合燃料发电机 | -1000W | CompPowerPlant | 化合燃料4.5/天 | Core |
| 风力发电机 | -2300W(峰值) | CompPowerPlantWind | 风速×产出 | Core |
| 太阳能发电机 | -1700W(峰值) | CompPowerPlantSolar | 日照×产出 | Core |
| 地热发电机 | -3600W | CompPowerPlantSteam | 需间歇泉 | Core |
| 水力发电机 | -1100W | CompPowerPlantWater | 需河流 | Core |
| 毒素发电机 | -3000W | CompPowerPlant | 持续污染地形 | Biotech |

**PowerNetTick电力平衡核心**：每tick计算`energyGainRate`（所有PowerOn设备的EnergyOutputPerTick之和），电力充足时渐进式开启关闭的设备（每次5%，随机选取），电力不足时每20 ticks渐进式关闭消费设备（每次5%）。

**电池要点**：容量600Wd、充电效率50%（输入100Wd只存储50Wd）、自放电5W/tick、EMP眩晕时拒绝充电、故障时清空存储。充电采用均匀分配算法（随机打乱后平均充入），放电同样均匀分摊。

**短路机制**：两种触发路径——雨天淋雨（电池>100Wd）和Storyteller事件。效果按电池存储分级：任意电池>20Wd → 爆炸（半径=`clamp(sqrt(总能量)×0.05, 1.5, 14.9)`）+ 排空所有电池；≤20Wd → 仅起火。

> **要点**：
> 1. 发电机和电池在拓扑上是"连接器"而非"传输器"——它们连接到最近电线（≤6格），不构成电网骨架
> 2. 电力不足时关闭设备是随机的——玩家无法控制关闭优先级，需用电源开关手动分割电网实现优先级控制

📖 [建筑供电系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\建筑供电系统.md)

#### 5. 模组自定义工作台与特殊功能

社区模组通过5种扩展模式自定义工作台，按复杂度从低到高：**纯XML继承**（零C#）→ **Comp扩展标准工作台**（新资源/环境条件）→ **自定义Bill子类**（非标准操作对象）→ **Building_Enterable替代**（Pawn进入处理）→ **完全自定义工作流**（绕过Bill系统）。

**5种扩展模式对比**：

| # | 模式 | 需要C# | 适用场景 | 典型实例 |
|---|------|--------|---------|---------|
| 1 | **纯XML继承BenchBase** | 否 | 标准制造工作台 | 大多数模组工作台 |
| 2 | **Comp扩展标准工作台** | 是 | 新资源条件/环境副作用/自动产出 | VEF Building_ResourceWorkTable, Milira SunBlastFurnace |
| 3 | **自定义Bill子类** | 是 | 操作特定物品而非通用材料 | AlteredCarbon Bill_OperateOnThing/Bill_OperateOnStack |
| 4 | **Building_Enterable替代** | 是 | Pawn进入建筑被处理 | AlteredCarbon Building_SleeveGestator, 原版GrowthVat |
| 5 | **完全自定义工作流** | 是 | 绕过Bill系统的独立交互 | GD5 CompCommunicationStation, VEF CompConfigurableSpawner |

**3个代表性模组速查**：

| 模组 | 自定义工作台 | 核心特色 | 技术路径 |
|------|------------|---------|---------|
| **VEF（原版扩展框架）** | Building_ResourceWorkTable | 管道资源消耗型工作台（水/气/化学品） | Comp扩展 + CompResourceTrader |
| **AlteredCarbon（副本2重生）** | Building_NeuralEditor + Building_SleeveGestator | Gizmo选目标→自定义Bill操作特定物品；Enterable孵化器培育Pawn身体 | 自定义Bill + Building_Enterable |
| **Milira（米莉拉）** | Building_SunBlastFurnace | 使用时推送热量+室外故障+非法使用检测 | Comp扩展（环境副作用） |

**VEF扩展框架工具**：`RecipeInheritanceExtension`（DefModExtension）让工作台从其他工作台继承配方并按产品/配方白名单/黑名单过滤——模组新增"升级版工作台"只需XML配置`inheritRecipesFrom`+过滤条件，无需手动复制配方列表。

> **要点**：
> 1. 大多数模组工作台只需纯XML继承`BenchBase`——自动获得ITab_Bills+BillStack+WorkGiver_DoBill，通过`recipeUsers`/`ThingDef.recipes`绑定配方即可
> 2. 需要操作特定物品（而非通用材料）时，自定义Bill子类是标准做法——AlteredCarbon的`Bill_OperateOnThing`通过`targetThing`字段绑定操作目标，配合Gizmo选择UI替代ITab_Bills
> 3. 需要"Pawn进入建筑被处理"时，用`Building_Enterable`而非`Building_WorkTable`——原版GrowthVat/GeneExtractor/MechGestator都是此模式

📖 [模组自定义工作台与特殊功能](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\模组自定义工作台与特殊功能.md)

---

## 第11章 传送、远行与世界地图 ★☆☆

> **对应模组需求**：紧急脱离/Bail Out（实体7）、远征船（实体15）、R18紧急脱离传送Job、R34远征船消耗Trion

### 引导问题

1. 远行队（Caravan）系统的基本流程是什么？（组建→出发→旅途事件→到达）
2. 世界地图上有哪些可交互的地点？（其他据点、遗迹、贸易点……）
3. 穿梭机（Shuttle）系统是怎么工作的？（Royalty DLC）
4. 传送类效果你见过哪些？（跳跃包、传送能力……）
5. 远行和传送在游戏体验上有什么区别？

### 你的笔记

#### 1. 远行队（Caravan）系统基本流程

远行队（`Caravan`）继承自`WorldObject`，是世界地图层的核心移动单位。内含8个子Tracker协作：`pather`（寻路）、`tweener`（动画）、`trader`（贸易）、`forage`（觅食）、`needs`（需求）、`carryTracker`（搬运）、`beds`（床铺）、`babies`（婴儿，Biotech）。

**完整生命周期4阶段**：

| # | 阶段 | 核心系统 | 关键类 |
|---|------|---------|--------|
| 1 | **组建** | LordJob状态机 | `LordJob_FormAndSendCaravan`（6步：集合动物→收集物品→搬运倒地者→等待→收拢动物→离开） |
| 2 | **移动** | A*世界寻路 | `Caravan_PathFollower`（成本=caravanTicksPerMove × 地形难度 × 道路倍率） |
| 3 | **旅途** | 8子Tracker | 需求更新+觅食+医疗+药物+夜间休息（22:00~06:00）+负重检查 |
| 4 | **到达** | ArrivalAction | `CaravanArrivalAction`（8子类：进入/攻击/访问/贸易/赠礼/任务/和谈/逃生飞船） |

**远行队事件**（按生物群系MTB触发）：敌对伏击（Ambush，MTB 20~60天）、猎人伏击（ManhunterAmbush）、勒索（CaravanDemand）、友好遭遇（CaravanMeeting，MTB 10~80天）。伏击会在远行队位置生成临时地图（`CaravansBattlefield`）。

**传送与穿梭机**（5种跨地图机制）：PawnFlyer（地图内跳跃）、Skip传送（灵能，`CompAbilityEffect_Teleport`直接修改Position+眩晕）、运输舱（`CompLaunchable`→`TravellingTransporters`单向发射）、帝国穿梭机（`CompShuttle`可往返）、重力船（Odyssey `Gravship`支持轨道层）。

> **要点**：
> 1. 自定义远行队事件只需IncidentDef(targetTags=Caravan) + IncidentWorker子类，配置mtbDaysByBiome控制触发频率
> 2. 地图内传送用PawnFlyer（物理跳跃）或CompAbilityEffect_Teleport（灵能传送），世界地图传送用CompLaunchable+TravellingTransporters

📖 [远行队系统基本流程](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\远行队系统基本流程.md)

#### 2. 世界地图可交互地点

世界地图上所有可交互地点都是`WorldObject`子类，由`WorldObjectsHolder`统一管理。分两大类：**动态地点**（远行队/运输舱/重力船，在世界地图上移动）和**静态地点**（据点/任务地点/遗迹，继承`MapParent`可生成地图）。

**WorldObject类继承体系**：

```
WorldObject（基类）
├── 动态: Caravan, TravellingTransporters, Gravship, RoutePlannerWaypoint
└── MapParent（地图容器）
    ├── Settlement（据点，玩家/NPC）
    ├── Site（通用任务地点，SitePartDef组合）
    ├── Camp（临时营地，200×200）
    ├── EscapeShip（逃生飞船）
    ├── CaravansBattlefield（伏击战场）
    ├── SpaceMapParent（轨道地图，Odyssey）
    └── PocketMapParent（口袋地图）
```

**WorldObjectComp组件系统**（类似ThingComp）：`FormCaravan`（允许组建远行队）、`TimedDetectionRaids`（停留过久触发袭击）、`Abandon`（放弃据点）、`Timeout`（超时消失）、`EnterCooldown`（进入冷却）等12个核心Comp。

**Site任务地点**：最通用的地点类型——通过`SitePartDef`组合实现任意任务场景（敌人营地+物资藏匿+倒地难民等），9个Comp提供完整功能。

**Odyssey轨道层**：`PlanetLayerDef`引入双层行星（地表+轨道），`SpaceMapParent`是轨道地图基类，`requiresSignalJammerToReach`控制需要信号干扰器才能接近的目标。

> **要点**：
> 1. 模组新增世界地图地点只需WorldObjectDef(XML) + WorldObjectComp——大多数不需要自定义C#类
> 2. Site是最灵活的地点类型——通过SitePartDef组合+9个Comp覆盖绝大多数任务场景

📖 [世界地图可交互地点](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\世界地图可交互地点.md)

#### 3. 穿梭机（Shuttle）系统

穿梭机是RimWorld中可往返的世界地图运输工具，与运输舱的单向消耗模式形成对比。三层架构：`TransportShipDef`（定义层，6字段）→ `TransportShip`（运行时实例，ShipJob状态机驱动）→ `CompShuttle` + `CompTransporter`（组件层）。

**两种穿梭机来源**：

| 维度 | 帝国穿梭机（Royalty） | 玩家穿梭机（Odyssey） |
|------|---------------------|---------------------|
| 获取方式 | 皇室许可召唤（Knight+，40天CD） | 建造（Steel 250+Plasteel 150+ShuttleEngine） |
| 核心Comp | CompShuttle + CompTransporter | + CompLaunchable + CompRefuelable |
| 可重用 | 否（任务结束飞走） | 是（着陆后保留，可再次发射） |
| 燃料 | 无（无限） | Chemfuel（容量400，3/格） |
| 最大距离 | 70格 | 62格 |
| 质量容量 | 2000 | 500 |
| 装载约束 | 任务系统设置required | playerShuttle=true（无限制） |

**ShipJob状态机**（穿梭机行为驱动，类似Pawn的Job系统）：

```
ShipJob（基类）
├── ShipJob_Arrive        ← 着陆：Skyfaller天降
├── ShipJob_Wait（抽象）   ← 等待：提供Gizmo按钮
│   ├── WaitTime（定时）/ WaitForever（永久）/ WaitSendable（条件发送）
├── ShipJob_FlyAway       ← 起飞：Skyfaller离开→世界地图飞行物
└── ShipJob_Unload        ← 卸载：每60 ticks卸载一个
```

**帝国穿梭机召唤流程**：`RoyalTitlePermitWorker_CallShuttle.CallShuttle()` → 创建Shuttle实体 → `TransportShipMaker.MakeTransportShip()` → `ArriveAt()` → 排队`[WaitForever, Unload_Destination, FlyAway]`。

**穿梭机 vs 运输舱核心差异**：穿梭机起飞时通过`activeTransporter.Contents.SetShuttle(shipThing)`保存实体引用，到达目的地后`TransportersArrivalAction_TransportShip`重新Spawn穿梭机——这是"可往返"的关键。运输舱则在发射后`parent.Destroy()`直接销毁。

**CompShuttle装载约束**：13个字段控制装载规则——`requiredItems`/`requiredPawns`（必需物品/Pawn）、`acceptColonists`/`permitShuttle`（接受范围）、`autoload`（每120 ticks自动检查并创建Lord让Pawn前往装载）。`playerShuttle=true`时跳过所有约束。

> **要点**：
> 1. 穿梭机系统的核心是TransportShip+ShipJob状态机——模组自定义穿梭机行为可通过自定义ShipJob子类实现，XML定义ShipJobDef+C#实现ShipJob子类
> 2. 帝国穿梭机与任务系统深度集成（6个QuestPart），玩家穿梭机则通过CompLaunchable独立运作——模组设计"远征船"应参考玩家穿梭机模式（CompLaunchable+CompRefuelable+CompShuttle）

📖 [穿梭机系统与TransportShip架构](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\穿梭机系统与TransportShip架构.md)

#### 4. 传送类效果完整分类

RimWorld的传送/位移效果分两大技术路径——**PawnFlyer**（物理飞行，Pawn被临时替换为飞行Thing沿抛物线移动）和**CompAbilityEffect_Teleport**（灵能瞬移，直接修改Position无飞行过程）。按作用范围分三层：地图内、跨地图、地图间传送门。

**两大技术路径核心差异**：

| 维度 | PawnFlyer（物理飞行） | CompAbilityEffect_Teleport（灵能瞬移） |
|------|---------------------|--------------------------------------|
| 核心机制 | Pawn.DeSpawn→替换为飞行Thing→抛物线飞行→RespawnPawn | 直接`target.Thing.Position = destination.Cell` |
| 飞行过程 | 有（可见轨迹+阴影） | 无（瞬间传送） |
| Job | `CastJump`（专用） | 通用能力Job |
| 携带物品 | `flyWithCarriedThing`支持 | 不支持 |
| DLC | Core | Royalty |

**地图内传送效果完整列表**（10种）：

| # | 效果 | DLC | 技术路径 | 射程 | 消耗 | 特殊行为 |
|---|------|-----|---------|------|------|---------|
| 1 | **跳跃包** | Royalty | PawnFlyer(Verb_Jump) | LOS | Chemfuel×20/次，5次 | 装备赋予，可携带倒地者 |
| 2 | **基因长跳** | Biotech | PawnFlyer(Ability) | 19.9格 | Hemogen 0.05 | 基因赋予，无限使用 |
| 3 | **机械体跳跃** | Biotech | PawnFlyer(Ability) | 9.9格 | 无 | minRange=5.9 |
| 4 | **机械体跳跃发射器** | Biotech | PawnFlyer(Ability) | 15格 | 2次充能，CD 8h | 可携带物品 |
| 5 | **吞噬跳跃** | Anomaly | PawnFlyer(ConsumeLeap) | 9.9格 | 无 | 着陆后消化目标 |
| 6 | **肉兽涌出** | Anomaly | PawnFlyer_Stun | — | — | 着陆后眩晕 |
| 7 | **Chaos Skip** | Royalty | Teleport(RandomInRange) | 24.9格 | 熵18+灵能0.02 | 随机传送6.9~24.9格，眩晕70~120t |
| 8 | **Skip** | Royalty | Teleport(Selected) | 27.9格 | 熵25+灵能0.02 | 玩家选择目标，眩晕18~60t |
| 9 | **Entity Skip** | Anomaly | Teleport(Selected) | 99.9格 | 无，CD 3~8秒 | 无LOS/无眩晕/无体型限制 |
| 10 | **Unnatural Corpse Skip** | Anomaly | Teleport(Selected) | 99.9格 | 无，CD 20秒 | 不自然尸体专用 |

**跨地图传送**（3种）：运输舱（Core，单向，CompLaunchable→TravellingTransporters）、穿梭机（Royalty/Odyssey，双向，CompShuttle+TransportShip）、Farskip（Royalty，灵能，5级，消耗Psyfocus 0.7，需目标地图有友方Pawn作"导航信标"）。

**地图间传送门**（2种）：MapPortal（Anomaly，连接主地图↔口袋地图，双向通道）、PitGate（Anomaly，连接主地图↔深渊地图）。

> **要点**：
> 1. 地图内物理跳跃用PawnFlyer（装备用Verb_Jump+CompApparelReloadable，能力用Verb_CastAbilityJump+AbilityDef），灵能瞬移用CompAbilityEffect_Teleport——两者完全独立，不共享代码
> 2. PawnFlyer.RespawnPawn()是virtual方法——模组自定义着陆效果（如着陆伤害、着陆Hediff）只需重写此方法，无需Harmony
> 3. ICompAbilityEffectOnJumpCompleted接口——AbilityComp实现此接口可在PawnFlyer着陆时执行自定义逻辑，是"跳跃+着陆效果"的标准扩展点

📖 [传送类效果完整分类](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\传送类效果完整分类.md)

#### 5. 远行与传送的游戏体验差异

远行队（Caravan）和传送是RimWorld中两种截然不同的跨地图移动方式，在时间成本、风险模型、资源消耗、玩家体验4个维度形成鲜明对比。

**核心差异对比表**（8个维度）：

| 维度 | 远行队（Caravan） | 传送（运输舱/穿梭机/Farskip） |
|------|-----------------|-----------------------------|
| **时间成本** | 数天~数十天（受地形/道路/负重影响） | 瞬间~数小时（运输舱飞行时间） |
| **风险模型** | 持续风险（伏击/勒索/食物耗尽/疲劳） | 一次性风险（着陆点安全性） |
| **资源消耗** | 食物+药品（持续消耗，可觅食补充） | 燃料（一次性消耗，运输舱Chemfuel 2.25/格） |
| **人员限制** | 无上限（受负重限制） | 有上限（运输舱容量/穿梭机质量500~2000） |
| **物资运输** | 大量（受负重容量限制，动物增加容量） | 有限（受容器容量限制） |
| **可逆性** | 双向（可随时返回，但需再走一遍） | 单向（运输舱）或双向（穿梭机/Farskip） |
| **旅途事件** | 有（伏击/猎人伏击/勒索/友好遭遇） | 无（传送过程无事件） |
| **殖民地影响** | 成员离开期间无法工作/防御 | 成员离开期间无法工作/防御（但时间更短） |

**设计哲学对比**：

| 维度 | 远行队 | 传送 |
|------|--------|------|
| **核心体验** | "旅途即冒险"——过程本身是游戏内容 | "目的地即内容"——跳过过程直达目标 |
| **风险分布** | 分散风险（每天都可能遇到事件） | 集中风险（着陆瞬间最危险） |
| **资源模型** | 持续消耗+可补充（觅食/贸易） | 一次性消耗不可补充 |
| **战略价值** | 贸易/外交/探索（慢但全面） | 军事打击/紧急救援（快但受限） |
| **解锁条件** | 无（游戏开始即可） | 需科研/DLC（运输舱需科研，穿梭机需Royalty） |

**各传送方式的战略定位**：

| 传送方式 | 战略定位 | 典型使用场景 |
|---------|---------|------------|
| **运输舱** | 单向快速投送 | 突袭敌方据点、紧急物资投送、殖民者快速部署 |
| **帝国穿梭机** | 任务专用往返 | 皇室任务、帝国贸易、紧急撤离 |
| **玩家穿梭机** | 可重用往返 | 常规远距贸易、多据点管理 |
| **Farskip** | 紧急全队传送 | 远行队紧急撤回、跨地图增援 |
| **重力船** | 轨道层探索 | Odyssey任务、轨道目标 |

**远行队的不可替代性**：
1. **大规模物资运输**——远行队可携带数千单位物资（动物增加负重），运输舱/穿梭机容量有限
2. **旅途贸易**——远行队可在途中遇到友好商队进行贸易，传送无此机会
3. **零科研门槛**——远行队不需要任何科研或DLC，是最基础的跨地图手段
4. **多据点管理**——远行队可在多个据点间灵活移动，不受燃料限制

**传送的不可替代性**：
1. **时间敏感任务**——限时任务（如救援、贸易窗口）远行队可能来不及
2. **军事突袭**——运输舱空降直接进入战斗，远行队需从地图边缘进入
3. **紧急撤离**——Farskip可瞬间将整个远行队传回基地
4. **跨越障碍**——传送无视地形难度，远行队受地形/道路严重影响

> **要点**：
> 1. 远行队和传送不是替代关系而是互补关系——远行队适合"慢节奏大规模"场景，传送适合"快节奏精确打击"场景
> 2. 模组设计"远征船"应考虑在远行队和传送之间找到独特定位——比如"可重用+大容量+需Trion燃料"的中间方案
> 3. Farskip是唯一的"紧急全队传送"手段——模组的"紧急脱离"（Bail Out）可参考此设计，但作用于地图内（传送到安全位置）而非跨地图

---

## 第12章 视觉与渲染 ★☆☆

> **对应模组需求**：战斗体外观切换（R11触发体激活时的视觉变化）

### 引导问题

1. Pawn的外观由哪些部分组成？（身体、头部、头发、衣服、装备……）
2. 你见过Pawn外观动态变化的情况吗？（变异、机械化、装备切换……）
3. 装备的视觉表现是怎样的？（穿在身上、拿在手上、背在背上……）
4. 你见过模组改变Pawn外观的例子吗？（比如HAR、Alien Races……）

### 你的笔记

#### 1. Pawn外观组成部分

Pawn的外观由**PawnRenderTree**（渲染树）管理，采用树形节点架构。每个视觉元素是树上的一个`PawnRenderNode`节点，分**静态节点**（XML定义）和**动态节点**（运行时注入）两部分。

**外观组成要素**（按渲染层级从底到顶）：

| # | 要素 | 节点类 | 数据源 | baseLayer |
|---|------|--------|--------|-----------|
| 1 | **身体** | `PawnRenderNode_Body` | `story.bodyType.bodyNakedGraphicPath` | 0 |
| 2 | **身体纹身** | `PawnRenderNode_Tattoo_Body` | Ideology纹身定义 | 2 |
| 3 | **身体衣物** | `PawnRenderNode_Apparel` | `pawn.apparel`（动态注入） | 20 |
| 4 | **头部** | `PawnRenderNode_Head` | `story.headType.GetGraphic()` | 50 |
| 5 | **头部纹身** | `PawnRenderNode_Tattoo_Head` | Ideology纹身定义 | 52 |
| 6 | **胡须** | `PawnRenderNode_Beard` | `story.beardDef` | 60 |
| 7 | **头发** | `PawnRenderNode_Hair` | `story.hairDef` | 62 |
| 8 | **头部衣物** | `PawnRenderNode_Apparel` | `pawn.apparel`（动态注入） | 70 |
| 9 | **毛皮覆盖** | `PawnRenderNode_Fur` | `story.furDef`（基因驱动） | 动态 |
| 10 | **基因视觉** | 动态节点 | 活跃基因的graphicData | 动态 |
| 11 | **Hediff视觉** | 动态节点 | Hediff的graphicData | 动态 |
| 12 | **武器/携带物** | Carried节点 | 当前装备/携带物 | 特殊 |

**动态节点注入**——5种`DynamicPawnRenderNodeSetup`子类在渲染树构建时注入节点：Apparel（衣物）、Genes（基因）、Hediffs（健康状态）、Traits（特性）、Mutants（变异体）。此外，任何`ThingComp`可通过重写`CompRenderNodes()`注入自定义节点。

**外观数据存储**——`Pawn_StoryTracker`持有7个核心字段：bodyType（体型，6种）、headType（头型）、hairDef（发型）、hairColor（发色）、skinColorBase（肤色）、furDef（毛皮）、melanin（黑色素）。

> **要点**：
> 1. 渲染树是**静态+动态**混合架构——XML定义骨架，运行时按Pawn当前状态注入衣物/基因/Hediff等动态节点
> 2. 外观变化后必须调用`SetAllGraphicsDirty()`触发渲染树重建——这是所有外观切换的统一刷新入口
> 3. 模组扩展外观最推荐的方式是`ThingComp.CompRenderNodes()`——无需Harmony，可注入任意自定义渲染节点

📖 [Pawn外观组成与渲染树系统](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Pawn外观组成与渲染树系统.md)

#### 2. Pawn外观动态变化机制

所有外观动态变化通过统一入口`PawnRenderer.SetAllGraphicsDirty()`触发渲染树完整重建。代码中有40+个调用点，分布在12大类场景中。渲染树采用**惰性重建**策略（SetDirty仅标记，下次渲染时才重建）。

**12大类触发场景**：

| # | 触发类别 | 调用位置 | 典型场景 |
|---|---------|---------|---------|
| 1 | **基因变化** | `Gene.PostAdd()/PostRemove()` | 基因添加/移除/Xenogerm植入 |
| 2 | **Hediff变化** | `Pawn_HealthTracker` | 添加/移除有视觉效果的Hediff |
| 3 | **衣物变化** | `Pawn_ApparelTracker` | 穿戴/脱下衣物 |
| 4 | **变异体** | `Pawn_MutantTracker.Turn()/Revert()` | 蹒跚者转化/恢复 |
| 5 | **年龄阶段** | `LifeStageWorker` | 婴儿→儿童→成人 |
| 6 | **风格变化** | `Dialog_StylingStation` | 发型/胡须/纹身修改 |
| 7 | **特性变化** | `TraitSet` | 有视觉效果的特性添加/移除 |
| 8 | **手术** | `Recipe_RemoveBodyPart` | 截肢影响头部渲染 |
| 9 | **隐身** | `HediffComp_Invisibility` | 切换透明着色器 |
| 10 | **吞噬者** | `CompDevourer` | 吞噬/消化/吐出改变体型 |

**PawnRenderNode_Body.GraphicFor()优先级链**（从高到低）：干尸→变异体→CreepJoiner→正常bodyType。变异体转化时，`MutantDef.bodyTypeGraphicPaths`完全替换身体贴图。

**8种原版动态外观变化先例**：变异体全身替换（★★★最深）、基因毛皮覆盖、基因/Hediff视觉附件、隐身透明化、吞噬者膨胀、年龄阶段变化、干尸化。

> **要点**：
> 1. `HasDefinedGraphicProperties`是性能守门员——只有`renderNodeProperties`非空的Def才触发渲染树重建
> 2. 模组实现"状态切换外观变化"推荐用Hediff标记+renderNodeProperties（纯XML，完全可逆，无C#）
> 3. 外观变化后必须调用`SetAllGraphicsDirty()`——这是所有外观切换的统一刷新入口

📖 [Pawn外观动态变化机制](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\Pawn外观动态变化机制.md)

#### 3. 装备视觉表现与渲染机制

装备视觉分两条完全独立的渲染路径——**衣物**在渲染树内（`PawnRenderNode_Apparel`），**武器/携带物**在渲染树外（`PawnRenderNodeWorker_Carried.PostDraw()`）。

**衣物贴图解析三种路径**：

| 衣物类型 | 贴图路径 | 体型后缀 | 说明 |
|---------|---------|---------|------|
| **普通身体衣物** | `wornGraphicPath + "_" + bodyType` | ✅ 有 | 每种体型独立贴图 |
| **头部衣物(Overhead/EyeCover)** | `wornGraphicPath` | ❌ 无 | 所有体型共用 |
| **背包(Belt层Pack)** | `wornGraphicPath` | ❌ 无 | 通过WornGraphicData控制偏移/缩放 |

**衣物层级特殊处理**：Shell层衣物北向layer=88（渲染在头部后方），Pack背包北向layer=93/南向layer=-3（实现"背在背上"效果）。

**武器渲染双模式**：
- **瞄准模式**（`DrawEquipmentAiming`）：武器旋转指向目标，含后坐力偏移，面朝左时水平翻转
- **携带模式**（`DrawCarriedWeapon`）：武器在四方向固定偏移位置，面朝西时翻转

**CarryWeaponOpenly 6条件判定**：征召、Job.alwaysShowWeapon、Duty.alwaysShowWeapon、LordJob.AlwaysShowWeapon、CompsWantHoldWeapon()——任一为true即显示武器。

**DrawWornExtras扩展通道**：`Apparel.DrawWornExtras()`遍历所有Comp调用`CompDrawWornExtras()`，原版唯一使用者是`CompShield`（护盾气泡）。

> **要点**：
> 1. 衣物和武器是完全独立的两条渲染路径——衣物在渲染树内随身体绘制，武器在PostDraw中独立绘制
> 2. `CompDrawWornExtras()`是在Pawn身上绘制额外视觉特效（光环/护盾/粒子）的标准通道
> 3. `CompsWantHoldWeapon()`是模组让武器在非征召时显示的标准扩展点

📖 [装备视觉表现与渲染机制](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\装备视觉表现与渲染机制.md)

#### 4. 模组改变Pawn外观实例

社区模组通过5种技术路径改变Pawn外观，按侵入性从低到高：**renderNodeProperties**（纯XML）→ **CompRenderNodes**（C#无侵入）→ **Story字段修改**（C#轻量）→ **自定义PawnRenderNode/Worker**（C#中量）→ **Harmony补丁GraphicFor**（C#高侵入）。

**4个代表性模组速查**：

| 模组 | 核心技术 | 外观变化范围 | 侵入性 |
|------|---------|------------|--------|
| **HAR（外星人框架）** | ThingDef子类+Harmony补丁+CompRenderNodes | ★★★ 全面替换（身体/头部/骨架贴图+BodyAddon附加物+衣物适配+缩放） | 高（50+补丁） |
| **CeleTech（天工铸造）** | ThingComp.Notify_Equipped修改story字段 | ★☆☆ 体型切换（Hulk/Fat→Male/Female） | 低（零补丁） |
| **AncotLibrary** | 自定义PawnRenderNode构造时判定 | ★☆☆ 条件渲染（按身体部位存在性） | 低（零补丁） |
| **VEF（原版扩展框架）** | AestheticScaling缓存+Harmony补丁 | ★★☆ Pawn缩放（基因/Hediff驱动） | 中 |

**HAR核心架构**：`ThingDef_AlienRace : ThingDef`定义种族级外观——`GraphicPaths`替换7条贴图路径（body/head/skeleton/skull/stump/swaddle/bodyMasks）、`AlienPartGenerator.BodyAddon`定义附加视觉元素（尾巴/角/翅膀，8+配置字段含drawSize/offsets/alignWithHead/inFrontOfBody）、`AlienComp.CompRenderNodes()`注入`AlienPawnRenderNode_BodyAddon`渲染节点、`ApparelGraphicsOverrides`三层衣物贴图适配（pathPrefix全局替换/individualPaths单件覆盖/bodyTypeFallback体型回退）。

**CeleTech体型切换模式**：`Comp_BodyshapeAjuster`在`Notify_Equipped()`中保存原始bodyType并切换为标准体型，`Notify_Unequipped()`恢复——最轻量的"装备改变外观"实现，可扩展到发型/头型/肤色。

**AncotLibrary条件渲染**：`PawnRenderNode_BodyPart`在构造函数中检查`AncotUtility.HasNamedBodyPart()`，通过`canDrawNow`标记控制后续渲染——适合"有手才显示手部装饰"等场景。

> **要点**：
> 1. HAR是社区种族模组的事实标准——VRE（原版种族扩展）等几乎所有种族模组都依赖HAR框架，1.6版本已迁移BodyAddon到原版`CompRenderNodes()`API
> 2. 不需要创建新种族时，优先用原版扩展点——`renderNodeProperties`（纯XML附加视觉）和`CompRenderNodes()`（C#动态注入）覆盖大多数场景，无需Harmony补丁
> 3. 装备改变外观用`Notify_Equipped`/`Notify_Unequipped`保存恢复模式——CeleTech的实现是最简模板，修改后记得调用`SetAllGraphicsDirty()`

📖 [模组改变Pawn外观实例](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\模组改变Pawn外观实例.md)

---

## 第13章 科研系统 ★☆☆

> **对应模组需求**：触发器解锁（待定，可能通过科研树实现）

### 引导问题

1. 科研系统的基本流程是什么？（科研台→选择项目→研究→解锁）
2. 科研树的结构是什么样的？（前置条件、分支、DLC科研……）
3. 科研完成后解锁的内容有哪些类型？（建筑、配方、能力……）
4. 你见过模组自定义的科研树吗？它们怎么和原版科研融合？

### 你的笔记

#### 1. 科研系统基本流程

三层架构：`ResearchProjectDef`（定义层，30+字段）→ `ResearchManager`（管理层，追踪进度/完成）→ `JobDriver_Research`（执行层，Pawn在研究台工作）。

**完整研究流程**：玩家在科研UI选择项目 → `ResearchManager.SetCurrentProject()` → 殖民者前往研究台 → `JobDriver_Research`每tick贡献研究点数（4000 ticks一轮）→ 进度达到baseCost → `FinishProject()`执行13步完成流程。

**研究速度公式**：`研究点数/tick = ResearchSpeed(Pawn) × ResearchSpeedFactor(研究台) × 0.00825 × 难度倍率 / CostFactor(科技等级差)`

| 研究台 | ResearchSpeedFactor | 需电力 | 支持设施 | 解锁条件 |
|--------|--------------------|----|---------|---------|
| **SimpleResearchBench** | 0.75 | 否 | 无 | 无（游戏开始可建） |
| **HiTechResearchBench** | 1.0 | 是(250W) | MultiAnalyzer | 需研究Microelectronics |

**CostFactor科技惩罚**：玩家派系科技等级低于项目等级时，每差1级增加0.5×惩罚（cap在Industrial=4，即Spacer/Ultra项目不额外惩罚）。

> **要点**：
> 1. 研究台在Laboratory房间中工作获得加成，不在实验室中减速20%（`workTableNotInRoomRoleFactor=0.8`）
> 2. `Building_ResearchBench`是极简类（仅GetInspectString），所有逻辑在ResearchManager和JobDriver中

📖 [科研系统架构与研究流程](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\科研系统架构与研究流程.md)

#### 2. 科研树结构

科研树由`ResearchTabDef`（标签页）+ `prerequisites`（前置链）+ `TechLevel`（科技等级）三维度组织。

**2个ResearchTabDef**：Main（Core，默认）和 Anomaly（Anomaly DLC，`visibleByDefault=false`，需石碑等级≥1才显示）。模组可定义新标签页。

**前置条件体系**：

| 字段 | 说明 |
|------|------|
| `prerequisites` | 显式前置——UI中显示连线，必须全部完成 |
| `hiddenPrerequisites` | 隐式前置——不显示连线，但必须完成 |

**TechLevel 7级**：Undefined → Animal → Neolithic → Medieval → Industrial → Spacer → Ultra → Archotech。原版科研树从左到右按科技等级排列。

**4种DLC特殊解锁条件**：

| DLC | 条件 | 机制 |
|-----|------|------|
| **Royalty** | `techprintCount` | 需收集techprint物品后才能开始研究 |
| **Biotech** | `requiredAnalyzed` | 需分析特定物品（如SignalChip）后才能研究 |
| **Biotech** | `requiresMechanitor` | 需殖民地有机械师 |
| **Anomaly** | `knowledgeCategory` + `knowledgeCost` | 独立知识系统，Basic/Advanced双轨并行+溢出 |

> **要点**：
> 1. Anomaly知识系统是独立于baseCost的第二条研究路径——通过研究异常实体获得知识点，Advanced溢出到Basic
> 2. `CanStartNow`判定链：前置完成 → techprint足够 → 分析完成 → 机械师要求满足

📖 [科研系统架构与研究流程](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\科研系统架构与研究流程.md)

#### 3. 科研完成后解锁内容

科研解锁采用"被动声明"模式——不是ResearchProjectDef声明"我解锁什么"，而是各Def通过`researchPrerequisite(s)`声明"我需要什么科研"。`UnlockedDefs`属性运行时反向搜索6种Def类型：

| # | 解锁类型 | 搜索的Def | 典型实例 |
|---|---------|----------|---------|
| 1 | **配方产品** | RecipeDef.products | 研究Smithing→解锁长剑制造 |
| 2 | **建筑/物品** | ThingDef | 研究Electricity→解锁电力建筑 |
| 3 | **可种植植物** | ThingDef.plant.sowResearchPrerequisites | 研究TreeSowing→解锁种树 |
| 4 | **地板** | TerrainDef | 研究StonecutterTable→解锁石质地板 |
| 5 | **手术** | RecipeDef（IsSurgery） | 研究Prosthetics→解锁安装假肢 |
| 6 | **心灵仪式** | PsychicRitualDef | Anomaly DLC仪式 |

**DesignationCategoryDef科研解锁**：整个建筑师菜单分类可被科研锁定——Power分类需Electricity，Biotech分类需BasicMechtech。

**ResearchMod**：抽象基类，`Apply()`方法在科研完成时调用。原版无子类实现，是模组的预留扩展点。

> **要点**：
> 1. 解锁是"被动声明"——在ThingDef/RecipeDef上设置researchPrerequisites，而非在ResearchProjectDef上声明解锁列表
> 2. ResearchMod是"科研完成时执行代码"的标准扩展点——继承重写Apply()即可，无需Harmony

📖 [科研解锁机制与模组扩展](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\科研解锁机制与模组扩展.md)

#### 4. 模组自定义科研树

4种扩展模式：

| # | 模式 | 需要C# | 适用场景 |
|---|------|--------|---------|
| 1 | **纯XML定义** | 否 | 标准科研项目+解锁建筑/配方 |
| 2 | **自定义ResearchTabDef** | 否 | 独立科研标签页 |
| 3 | **自定义ResearchMod子类** | 是 | 科研完成时执行代码逻辑 |
| 4 | **Harmony补丁** | 是 | 修改科研速度/条件/UI |

**UFHeavyIndustries（联合重工）代表性实例**：独立`KT_Research`标签页 + 双层抽象模板（low_Base无特殊要求 / high_Base需HiTech+MultiAnalyzer）+ T0→T1→T2（火炮/能量/磁轨分支）→T3→T4分级科技树，baseCost从1000递增到5000+。

**标准做法**：用Abstract模板统一techLevel/tab/requiredResearchBuilding，具体项目只需设置defName/label/baseCost/坐标/前置。researchViewX按层级递增，researchViewY按分支偏移，间距≥0.7避免重叠。

> **要点**：
> 1. 自定义标签页只需1行XML（`ResearchTabDef`），项目通过`<tab>`字段归入
> 2. 抽象模板继承是标准模式——UFHeavyIndustries的双层模板（low/high）是典型参考

📖 [科研解锁机制与模组扩展](C:\NiwtDatas\Projects\RimworldModStudio\模组知识\游戏百科\快速参考\科研解锁机制与模组扩展.md)

---

## 附录A DLC系统速查

> 记录各DLC提供的可用系统，明确哪些系统来自哪个DLC，避免选型时误用未购买DLC的功能。

| DLC | 提供的关键系统 | 与模组的关联 | 你的备注 |
|-----|--------------|------------|---------|
| **Royalty** | 超能力、帝国派系、穿梭机、心灵武器 | 传送参考、能力系统参考 | |
| **Ideology** | 意识形态、仪式、角色、风格 | 派系文化设定参考 | |
| **Biotech** | 基因系统、机械师、婴儿/成长 | Trion腺体（基因）、Trion兵（机械体） | |
| **Anomaly** | 异常实体、研究系统、恐惧 | 事件系统参考 | |

### 引导问题

1. 你安装了哪些DLC？
2. 每个DLC的核心系统你用过哪些？体验如何？
3. 有没有DLC系统之间互相依赖的情况？

### 你的备注



---

## 附录B 模组需求→章节映射

> 快速定位：2.6中的每个游戏实体和需实现关系，在本文档哪一章可以找到对应的引导问题。

### 15个游戏实体映射

| # | 实体 | Def类型 | 对应章节 |
|---|------|--------|---------|
| 1 | Trion腺体 | GeneDef | 第3章 基因系统 |
| 2 | Trion接收器（触发角） | HediffDef | 第1章 Pawn与健康系统 |
| 3 | 副作用（Side Effect） | TraitDef + AbilityDef | 第5章 能力与特性系统 |
| 4 | 触发体 | ThingDef | 第4章 装备与物品系统 |
| 5 | 触发芯片 | ThingDef | 第4章 装备与物品系统 |
| 6 | 黑触发器 | ThingDef | 第4章 装备与物品系统 |
| 7 | 紧急脱离（Bail Out） | 触发芯片实例 | 第4章 + 第11章 传送 |
| 8 | Trion兵 | PawnKindDef | 第9章 机械体与人工单位 |
| 9 | 近界民 | PawnKindDef | 第7章 派系系统 + 第9章 |
| 10 | 制造设施 | ThingDef | 第10章 建筑与工作台 |
| 11 | 母触发器（星触发器） | ThingDef | 第10章 建筑与工作台 |
| 12 | BORDER | FactionDef | 第7章 派系系统 |
| 13 | 敌对惑星国家派系 | FactionDef | 第7章 派系系统 |
| 14 | 门（Gate） | 特效+生成机制 | 第8章 事件与袭击系统 |
| 15 | 远征船 | ThingDef | 第11章 传送、远行与世界地图 |

### 14条需实现关系映射

| # | 关系 | 对应章节 |
|---|------|---------|
| R1 | Trion腺体 → Trion（产生） | 第2章 + 第3章 |
| R2 | Trion接收器 → Trion（增强） | 第1章 + 第2章 |
| R5 | Trion → 副作用（触发） | 第2章 + 第5章 |
| R6 | 黑触发器 → Trion（叠加） | 第4章 + 第2章 |
| R7 | 触发体 ⊃ 触发芯片（装载） | 第4章 |
| R11 | 触发体 → 战斗体系统（激活） | 第6章 + 第12章 |
| R12 | 触发体 → Trion（消耗） | 第2章 + 第6章 |
| R16 | 战斗体系统 → hediff（伤害隔离） | 第1章 + 第6章 |
| R18 | 紧急脱离 → 传送（保护） | 第6章 + 第11章 |
| R19 | 制造设施 → Trion兵（制造） | 第10章 + 第9章 |
| R21 | 近界民派系 → Trion兵（操控） | 第7章 + 第9章 |
| R33 | 门 → 袭击（生成） | 第8章 |
| R34 | 远征船 → Trion（消耗） | 第11章 + 第2章 |
| R35 | 死亡事件 → 黑触发器（生成） | 第8章 + 第4章 |

---

## 历史修改记录

| 版本 | 日期 | 修改摘要 | 签名 |
|------|------|---------|------|
| v0.1 | 2026-02-10 | 生成文档骨架：13章+2附录，覆盖2.6全部15实体和14关系 | Claude Opus 4.6 |
| v1.0 | 2026-02-10 | 完成第1章全部6节 + 第2章1-3节 | Claude Opus 4.6 |
| v3.0 | 2026-02-10~11 | 完成第5章全部5节 + 第6章2节 + 第8章全部5节 | Claude Opus 4.6 |
| v4.0 | 2026-02-11 | 奥卡姆剃刀优化：去除与参考文档重复的详细内容，精简开发者要点至2-3条，压缩历史记录。~2056行→~950行，信息零损失 | Claude Opus 4.6 |
| v5.0 | 2026-02-13 | 同步第9章第1节机械体译名至灰机wiki标准汉化（总览段落+速查表，如Centipede→机械蜈蚣、Lancer→机械静螳、Apocriton→憎恶毒蜂等） | Claude Opus 4.6 |
| v6.0 | 2026-02-15 | 完成第7章第4节（模组自定义派系与扩展模式：4种扩展模式纯XML/DefModExtension/WorldObjectComp/完整子系统、3代表性模组——NCL/TW双派系友敌分离+CompTameableMech驯服Gizmo→Job→SetFaction 50%成功率、GD5 BlackMechanoid任务驱动earliestRaidDays=999999+MissionComponent、Milira三派系体系permanentEnemyToEveryoneExcept+16个Combat组+WorldObjectCompMiliraSettlement定居点交互+royalTitleTags头衔、VEF FactionDefExtension 15+字段），第7章第1/2/3/4/5节完成，新建参考文档`模组自定义派系与扩展模式.md` | Claude Opus 4.6 |
| v6.8 | 2026-02-15 | 完成第11章第3节（穿梭机系统与TransportShip架构：三层架构TransportShipDef 6字段→TransportShip运行时实例ShipJob状态机→CompShuttle+CompTransporter组件、ShipJob继承体系4子类7个ShipJobDef——Arrive着陆Skyfaller+Wait三种等待模式WaitTime/WaitForever/WaitSendable+FlyAway起飞SetShuttle保留实体可往返+Unload每60ticks卸载、帝国穿梭机Royalty许可召唤RoyalTitlePermitWorker_CallShuttle+permitShuttle+任务系统6个QuestPart深度集成、玩家穿梭机Odyssey Building_PassengerShuttle+CompLaunchable fuelPerTile=3+CompRefuelable Chemfuel容量400+playerShuttle=true无装载约束、CompShuttle装载约束系统13字段requiredItems/requiredPawns/acceptColonists/autoload每120ticks自动装载+IsAllowed判定链+超时卸载60000ticks、帝国vs玩家vs运输舱12维度对比含可重用/燃料/距离/质量/行为驱动），第11章第1/2/3节完成，新建参考文档`穿梭机系统与TransportShip架构.md` | Claude Opus 4.6 |
| v7.0 | 2026-02-15 | 完成第11章第4/5节，第11章全部5节完成，新建参考文档`传送类效果完整分类.md` | Claude Opus 4.6 |
| v8.0 | 2026-02-15 | 完成第12章第2节（Pawn外观动态变化机制：SetAllGraphicsDirty统一入口5步清除+12大类触发场景40+调用点+HasDefinedGraphicProperties条件守门员+渲染树惰性重建流程+5种DynamicSetup重建行为+PawnRenderNode_Body/Head的GraphicFor优先级链+8种原版动态外观变化先例变异体/基因毛皮/Hediff视觉/隐身/吞噬者/年龄/干尸+3种模组推荐模式）+ 第12章第3节（装备视觉表现与渲染机制：双路径架构衣物渲染树内+武器渲染树外+ApparelGraphicRecordGetter三种贴图路径+Shell北向layer=88/Pack北向93南向-3+WornGraphicData方向×体型偏移缩放+武器瞄准/携带双模式+CarryWeaponOpenly 6条件+DrawWornExtras→CompDrawWornExtras扩展通道），第12章第1/2/3节完成，新建参考文档`Pawn外观动态变化机制.md`和`装备视觉表现与渲染机制.md` | Claude Opus 4.6 |
| v9.0 | 2026-02-16 | 完成第12章第4节（模组改变Pawn外观实例：5种技术路径renderNodeProperties/CompRenderNodes/Story字段修改/自定义Node+Worker/Harmony补丁、4代表性模组——HAR外星人框架ThingDef_AlienRace+GraphicPaths 7路径替换+BodyAddon附加物AlienComp.CompRenderNodes注入+AlienPawnRenderNodeWorker_BodyAddon自定义Worker+ApparelGraphicsOverrides三层衣物适配、CeleTech天工铸造Comp_BodyshapeAjuster装备驱动体型切换保存恢复模式、AncotLibrary PawnRenderNode_BodyPart条件渲染按身体部位存在性、VEF AestheticScaling基因Hediff驱动缩放），第12章全部4节完成，新建参考文档`模组改变Pawn外观实例.md` | Claude Opus 4.6 |
| v10.0 | 2026-02-16 | 完成第13章全部4节（科研系统：三层架构ResearchProjectDef 30+字段→ResearchManager进度追踪+FinishProject 13步完成流程→JobDriver_Research 4000ticks周期、研究速度公式ResearchSpeed×ResearchSpeedFactor×0.00825×难度÷CostFactor科技等级惩罚cap在Industrial、两种研究台Simple 0.75x无电/HiTech 1.0x需电+MultiAnalyzer、科研树结构ResearchTabDef 2标签页Main+Anomaly+prerequisites显式/隐式前置+TechLevel 7级、4种DLC特殊解锁条件Royalty techprint/Biotech requiredAnalyzed+requiresMechanitor/Anomaly知识双轨Basic+Advanced溢出、科研解锁6种Def类型被动声明模式+ResearchMod预留扩展点+DesignationCategoryDef科研锁定建筑师菜单、模组4种扩展模式纯XML/自定义Tab/ResearchMod子类/Harmony+UFHeavyIndustries代表性实例独立标签页+双层抽象模板+T0~T4分级科技树），第13章全部4节完成，新建参考文档`科研系统架构与研究流程.md`和`科研解锁机制与模组扩展.md` | Claude Opus 4.6 |