---
标题：4.2 RimWorld技术框架笔记
版本号: v0.9
更新日期: 2026-02-16
最后修改者: Claude Opus 4.6
标签：[文档][用户未确认][未完成][未锁定]
摘要: RimWorld代码架构与技术框架的系统性笔记。定位于技术实现层面——"RimWorld用什么Def/Comp/Worker来实现这些系统"。与4.1（游戏规则）互补，为第六阶段深度系统设计提供代码级参考。
---

# 4.2 RimWorld技术框架笔记

## 前置说明

**本文档是什么**：RimWorld代码架构的技术参考手册，记录Def类型、Comp体系、Worker模式、关键C#类结构和调用链。

**本文档不是什么**：不是游戏规则说明（那是4.1的职责），不是模组选型方案（那是4.3/4.4的职责）。

**4.1 / 4.2 / 4.3-4.4 三者边界**：
- 4.1 游戏系统笔记 → "游戏里有什么规则"（玩家视角）
- 4.2 技术框架笔记 → "代码里怎么实现的"（开发者视角）← 本文档
- 4.3/4.4 技术选型报告 → "BDP该怎么做"（模组设计视角）

**阅读建议**：按需查阅，非线性阅读。每章独立，通过引用链接到详细的快速参考文档。

**术语约定**：
| 术语 | 含义 |
|------|------|
| Def | XML数据定义（静态，加载时构建） |
| Comp | 组件（运行时附加到实体上的逻辑模块） |
| Worker | 委托工作器（执行特定计算或效果的策略类） |
| Tracker | 追踪器（Pawn级子系统管理器） |
| Gizmo | 命令按钮（游戏内UI交互元素） |
| Toil | 最小行为单元（Job系统的原子操作） |

**素材状态图例**：
- ✅ `[已有素材]` — 快速参考目录下有对应文件，本章提供概述+引用
- ⚠️ `[部分素材]` — 有相关文件但不完全对应，需补充
- ❌ `[待新建]` — 无现有素材，需从源码研究后新写

---

## 第1章 RimWorld代码架构总览 ✅ [已完成]

> **目标**：建立对RimWorld代码组织方式的全局认知

### 1.1 程序集结构 ✅

**核心程序集**：`Assembly-CSharp.dll`（位于`RimWorldWin64_Data/Managed/`），包含全部游戏逻辑。基于Unity引擎，运行时依赖`UnityEngine.*.dll`系列程序集。

#### 命名空间组织：双层架构

RimWorld采用**Verse（引擎层）+ RimWorld（游戏层）**的双层命名空间架构：

| 层级 | 命名空间 | 职责 | 典型类 |
|------|---------|------|--------|
| **引擎层** | `Verse` | 核心引擎：Thing/Map/Def/Tick/存档 | Thing, Map, Def, TickManager, Scribe |
| | `Verse.AI` | AI基础：Job系统、ThinkTree | JobDriver, ThinkNode, Pawn_JobTracker |
| | `Verse.AI.Group` | 群体AI：Lord系统 | Lord, LordJob, LordToil |
| | `Verse.Glow` | 光照计算 | GlowGrid, GlowFlooder |
| | `Verse.Grammar` | 文本语法生成 | GrammarResolver, Rule |
| | `Verse.Noise` | 噪声生成（地形等） | NoiseRenderer, ModuleBase |
| | `Verse.Profile` | 性能分析 | DeepProfiler, MemoryTracker |
| | `Verse.Sound` | 音频系统 | SoundDef, SoundStarter |
| | `Verse.Steam` | Steam集成 | WorkshopItems |
| | `Verse.Utility` | 引擎工具类 | 各种Utility |
| **游戏层** | `RimWorld` | 核心游戏逻辑：殖民/战斗/社交/科研 | Pawn, FactionDef, IncidentWorker |
| | `RimWorld.Planet` | 世界地图 | WorldObject, Caravan, Settlement |
| | `RimWorld.BaseGen` | 基地/遗迹生成 | SymbolResolver, BaseGen |
| | `RimWorld.QuestGen` | 任务生成 | QuestNode, QuestGen |
| | `RimWorld.SketchGen` | 建筑草图生成 | SketchResolver |
| | `RimWorld.IO` | 文件IO抽象 | VirtualDirectory |
| | `RimWorld.Utility` | 游戏工具类 | 各种Utility |
| **第三方** | `LudeonTK` | 开发者工具包 | DebugAction, DebugTool |
| | `Ionic.Zlib/Crc` | 压缩库 | — |
| | `RuntimeAudioClipLoader` | 运行时音频加载 | — |

#### 关键设计边界

- **Verse不依赖RimWorld**：Verse层是通用游戏引擎，理论上可用于非RimWorld项目。RimWorld层依赖Verse层，反之不成立。
- **模组DLL引用**：模组项目需引用`Assembly-CSharp.dll`（游戏逻辑）+ `UnityEngine.CoreModule.dll`（Unity核心）。根据需要可额外引用其他Unity模块。

### 1.2 游戏启动与加载流程 ✅

**入口方法**：`PlayDataLoader.DoPlayLoad()`，在游戏启动时由`LongEventHandler`调度执行。

#### 完整加载管线（按源码调用顺序）

```
阶段1：资源准备
├── GraphicDatabase.Clear()                    — 清空图形缓存
└── LoadedModManager.LoadAllActiveMods()        — 加载所有激活的模组 ★
    ├── XmlInheritance.Clear()                 — 清空XML继承缓存
    ├── InitializeMods()                       — 初始化模组列表（按LoadOrder排序）
    ├── LoadModContent()                       — 加载模组资源（贴图/音频/DLL）
    ├── CreateModClasses()                     — 实例化各模组的Mod子类
    ├── LoadModXML()                           — 加载所有Defs XML文件
    ├── CombineIntoUnifiedXML()                — 合并为统一XML文档
    ├── ApplyPatches()                         — 应用XPath补丁（Patches/）
    ├── ParseAndProcessXML()                   — 解析XML → 创建Def对象
    └── XmlInheritance.Clear()                 — 清理

阶段2：Def数据库构建
├── LanguageDatabase.InitAllMetadata()         — 加载语言元数据
├── DefDatabase<T>.AddAllInMods()              — 将Def注册到各类型数据库（并行）
├── DirectXmlCrossRefLoader.ResolveAll...()    — 第一轮交叉引用解析（静默模式）
├── DefOfHelper.RebindAllDefOfs(early)         — 早期DefOf绑定
├── TKeySystem.BuildMappings()                 — 翻译键映射
├── LanguageDatabase.InjectIntoData_Before...()— 语言注入（隐含Def前）
├── DefGenerator.GenerateImpliedDefs_Pre...()  — 生成隐含Def（如肉/皮革Def）
├── DirectXmlCrossRefLoader.ResolveAll...()    — 第二轮交叉引用解析（报错模式）
├── DefOfHelper.RebindAllDefOfs(final)         — 最终DefOf绑定
└── DefDatabase<T>.ResolveAllReferences()      — 所有Def解析引用（按特定顺序）
    ├── ThingCategoryDef（优先，并行）
    ├── RecipeDef（优先，并行）
    ├── 其他Def类型
    └── ThingDef（最后，因依赖最多）

阶段3：后处理
├── DefGenerator.GenerateImpliedDefs_Post...() — 生成后置隐含Def
├── ResetStaticDataPost()                      — 重置静态数据
├── ErrorCheckAllDefs()                        — Def错误检查（仅DevMode）
├── ShortHashGiver.GiveAllShortHashes()        — 分配短哈希（存档用）

阶段4：延迟执行（LongEventHandler.ExecuteWhenFinished）
├── SolidBioDatabase.LoadAllBios()             — 加载背景故事
├── LanguageDatabase.InjectIntoData_After...() — 语言注入（隐含Def后）
├── StaticConstructorOnStartupUtility.CallAll()— 调用所有[StaticConstructorOnStartup]类 ★
├── GlobalTextureAtlasManager.BakeStaticAtlases() — 烘焙纹理图集
└── GC.Collect() + UnloadUnusedAssets()        — 垃圾回收
```

#### 模组DLL加载时机

1. **DLL加载**：`LoadModContent()`阶段，按模组LoadOrder加载Assemblies/目录下的DLL
2. **Mod类实例化**：`CreateModClasses()`阶段，调用各模组`Mod`子类的构造函数
3. **Harmony补丁**：通常在`Mod`构造函数中执行`Harmony.PatchAll()`
4. **[StaticConstructorOnStartup]**：阶段4最后执行，此时所有Def已加载完毕，适合做依赖Def数据的初始化

#### 模组开发关键点

- **Mod构造函数**：Def尚未加载，不能访问DefDatabase。适合注册Harmony补丁、读取设置
- **[StaticConstructorOnStartup]**：所有Def已就绪，可安全访问DefDatabase。适合缓存Def引用、注册动态内容
- **DefOf字段**：标记`[DefOf]`的静态类会在`RebindAllDefOfs`时自动绑定，无需手动查询

### 1.3 游戏循环与Tick系统 ✅

**核心类**：`Verse.TickManager`，由Unity的`Update()`驱动，每帧调用`DoSingleTick()`。

#### Tick频率与时间换算

| 概念 | 值 | 说明 |
|------|---|------|
| 基础频率 | 60 ticks/秒（1倍速） | 每Tick约16.7ms |
| 1游戏小时 | 2500 ticks | — |
| 1游戏天 | 60000 ticks | — |
| NeedInterval | 150 ticks（2.5秒） | Need系统更新间隔 |
| TickRare | 250 ticks（约4.2秒） | 低频更新 |
| TickLong | 2000 ticks（约33秒） | 极低频更新 |

#### DoSingleTick()执行顺序

```
DoSingleTick()
├── 1. Map.MapPreTick()          — 所有地图的前置Tick（天气/温度/条件等）
├── 2. ticksGameInt++             — 游戏Tick计数器递增
├── 3. tickListNormal.Tick()      — Normal频率Thing的Tick（每Tick）
├── 4. tickListRare.Tick()        — Rare频率Thing的Tick（每250 Tick）
├── 5. tickListLong.Tick()        — Long频率Thing的Tick（每2000 Tick）
├── 6. DateNotifier.DateNotifierTick()    — 日期通知
├── 7. Scenario.TickScenario()            — 场景Tick
├── 8. World.WorldTick()                  — 世界地图Tick（远行队/定居点等）
├── 9. StoryWatcher.StoryWatcherTick()    — 故事监视器
├── 10. GameEnder.GameEndTick()           — 游戏结束检查
├── 11. Storyteller.StorytellerTick()     — 叙事者调度事件
├── 12. TaleManager.TaleManagerTick()     — 故事记录
├── 13. QuestManager.QuestManagerTick()   — 任务管理
├── 14. World.WorldPostTick()             — 世界后置Tick
├── 15. Map.MapPostTick()                 — 所有地图的后置Tick
├── 16. History.HistoryTick()             — 历史记录
├── 17. GameComponentUtility.GameComponentTick() — 所有GameComponent
├── 18. LetterStack.LetterStackTick()     — 信件管理
├── 19. Autosaver.AutosaverTick()         — 自动存档
└── 20. TransportShipManager.ShipObjectsTick()   — 运输船管理
```

#### TickList桶分配机制

TickList使用**桶（Bucket）分配**实现负载均衡，避免所有Thing在同一Tick更新：

- Normal列表：1个桶（每Tick全部执行）
- Rare列表：250个桶，每Tick只执行`ticksGame % 250`号桶
- Long列表：2000个桶，每Tick只执行`ticksGame % 2000`号桶

Thing注册到哪个桶由`thingIDNumber % TickInterval`决定，确保均匀分布。

**原理**：如果有2500个Thing注册了TickRare，每Tick只需处理约10个（2500/250），而非全部2500个。

#### Thing的Tick频率选择

Thing通过`ThingDef.tickerType`字段声明Tick频率：

| TickerType | 调用方法 | 间隔 | 适用场景 |
|-----------|---------|------|---------|
| `Never` | 不调用 | — | 静态物品（墙壁/地板） |
| `Normal` | `Tick()` | 每Tick | 需要精确计时（投射物/战斗） |
| `Rare` | `TickRare()` | 250 Tick | 中等频率（植物生长/腐烂） |
| `Long` | `TickLong()` | 2000 Tick | 低频率（建筑检查） |

**性能原则**：优先使用最低频率的TickerType。大多数Comp逻辑应在`CompTickRare()`中实现，仅战斗/动画等时间敏感逻辑使用`CompTick()`。

### 1.4 核心设计模式 ✅

RimWorld代码架构围绕四大设计模式构建，理解它们是模组开发的基础。

#### 模式1：Def-Instance分离（数据驱动）

**核心思想**：静态数据定义（Def）与运行时实例（Instance）分离。Def在加载时从XML构建，全局唯一；Instance在游戏运行时按需创建，可有多个。

```
ThingDef "MeleeWeapon_Longsword"  ←  XML定义，全局唯一
    ↓ 实例化
Thing 实例 #1（张三的长剑，耐久80%）
Thing 实例 #2（李四的长剑，品质精良）
Thing 实例 #3（地上掉的长剑）
```

| 概念 | Def（定义） | Instance（实例） |
|------|-----------|-----------------|
| 来源 | XML文件 | 运行时创建 |
| 数量 | 每种类型1个 | 可有多个 |
| 存储 | `DefDatabase<T>` | Map/Pawn/容器中 |
| 访问 | `DefDatabase<ThingDef>.GetNamed("...")` 或 `ThingDefOf.xxx` | `thing.def` 反向引用Def |
| 修改 | 不应运行时修改（影响所有实例） | 每个实例独立修改 |

**常见Def-Instance对**：

| Def类型 | 实例类型 | 说明 |
|---------|---------|------|
| ThingDef | Thing | 物品/建筑/Pawn的定义与实例 |
| HediffDef | Hediff | 健康状态的定义与实例 |
| GeneDef | Gene | 基因的定义与实例 |
| AbilityDef | Ability | 能力的定义与实例 |
| FactionDef | Faction | 派系的定义与实例 |
| PawnKindDef | Pawn（生成参数） | 种类定义（与ThingDef互补） |

#### 模式2：Comp组件模式（组合优于继承）

**核心思想**：通过附加Comp组件为实体添加功能，而非通过继承创建子类。一个ThingDef可配置多个Comp，运行时动态组合。

```
ThingDef "Gun_Rifle"
├── CompProperties_Forbiddable     → CompForbiddable（禁用控制）
├── CompProperties_Quality         → CompQuality（品质系统）
└── CompProperties_Art             → CompArt（艺术描述）
```

**五个层级的Comp体系**（详见第3章）：

| 层级 | Comp基类 | 配置方式 | 附加对象 |
|------|---------|---------|---------|
| Thing级 | ThingComp + CompProperties | XML `<comps>` | 物品/建筑/Pawn |
| Hediff级 | HediffComp + HediffCompProperties | XML `<comps>` | 健康状态 |
| WorldObject级 | WorldObjectComp + WorldObjectCompProperties | XML `<comps>` | 世界对象 |
| Map级 | MapComponent | C#注册 | 地图（单例） |
| Game级 | GameComponent | C#注册 | 游戏实例（单例） |

**为什么用Comp而非继承**：
- 继承是单链的，一个类只能继承一个父类
- Comp是组合的，一个Thing可以有任意多个Comp
- XML可配置，无需写C#代码就能组合功能
- 模组友好，不同模组可以为同一ThingDef添加不同Comp而不冲突

#### 模式3：Worker委托模式（策略模式）

**核心思想**：将特定计算或效果逻辑委托给Worker类，Def通过字段引用Worker类型。同一Def类型可通过不同Worker实现不同行为。

```
DamageDef "Cut"
└── workerClass = typeof(DamageWorker_AddInjury)  → 造成伤口

DamageDef "Stun"
└── workerClass = typeof(DamageWorker_Stun)        → 造成眩晕

DamageDef "Extinguish"
└── workerClass = typeof(DamageWorker_Extinguish)  → 灭火
```

**常见Worker体系**：

| Worker基类 | 引用位置 | 职责 | 子类数量 |
|-----------|---------|------|---------|
| `DamageWorker` | DamageDef.workerClass | 伤害计算与应用 | 4+ |
| `IncidentWorker` | IncidentDef.workerClass | 事件执行逻辑 | 60+ |
| `StatWorker` | StatDef.workerClass | 属性值计算 | 25+ |
| `ThinkNode` | ThinkTreeDef节点 | AI决策节点 | 大量 |
| `CompAbilityEffect` | AbilityDef.comps | 能力效果执行 | 大量 |
| `PlaceWorker` | ThingDef.placeWorkers | 建筑放置验证 | 多种 |
| `DesignatorDropdownGroupDef` | — | 建筑分组 | — |

**Worker vs Comp的区别**：
- **Worker**：无状态，执行计算/效果后即完成，不持有运行时数据
- **Comp**：有状态，附加在实例上，持有运行时数据，参与Tick/存档

#### 模式4：Tracker追踪器模式（子系统管理器）

**核心思想**：Pawn的复杂功能拆分为多个Tracker，每个Tracker管理一个子系统。Pawn类本身只持有Tracker引用，不直接实现逻辑。

```
Pawn
├── health    → Pawn_HealthTracker（健康/Hediff管理）
├── needs     → Pawn_NeedsTracker（需求系统）
├── jobs      → Pawn_JobTracker（行为调度）
├── equipment → Pawn_EquipmentTracker（装备管理）
├── genes     → Pawn_GeneTracker（基因系统）
├── abilities → Pawn_AbilityTracker（能力管理）
└── ...（40+个Tracker）
```

**Tracker的共同特征**：
- 持有对owner Pawn的引用
- 实现`IExposable`接口（存档支持）
- 提供`XxxTrackerTick()`方法（周期性更新）
- 封装子系统的全部数据和逻辑

**Tracker vs MapComponent/GameComponent**：
- Tracker是Pawn级的，每个Pawn实例各有一套
- MapComponent是地图级单例，GameComponent是游戏级单例
- 但设计思想相同：将复杂系统拆分为独立管理器

#### 四大模式的协作关系

```
XML定义层:  ThingDef ──→ CompProperties列表 ──→ workerClass引用
               │
               ↓ 实例化
运行时层:   Thing ──→ ThingComp列表 ──→ Worker执行
               │
               ↓ (如果是Pawn)
           Pawn ──→ Tracker列表 ──→ 各子系统逻辑
```

一个典型的游戏行为（如"Pawn使用护盾抵挡伤害"）会同时涉及：
1. **Def**：ShieldBeltDef定义护盾属性
2. **Comp**：CompShield管理护盾运行时状态（能量值、冷却）
3. **Worker**：DamageWorker计算伤害时调用CompShield的拦截逻辑
4. **Tracker**：Pawn_HealthTracker协调整个伤害处理流程

---

## 第2章 Def系统深度解析 ✅ [已完成]

> **目标**：理解RimWorld的数据驱动架构核心

### 2.1 Def体系总览 ✅

**核心类**：`Verse.Def`，继承自`Verse.Editable`，实现`IEquatable<Def>`。所有XML数据定义的基类。

#### Def继承链

```
Editable（基础可编辑对象）
├── Def（所有定义的基类）
│   ├── BuildableDef（可建造物基类，增加statBases/costList/placeWorkers等）
│   │   ├── ThingDef（物品/建筑/Pawn/投射物定义）★ 最复杂
│   │   └── TerrainDef（地形定义）
│   ├── HediffDef（健康状态定义）
│   ├── GeneDef（基因定义）
│   ├── AbilityDef（能力定义）
│   ├── FactionDef（派系定义）
│   ├── PawnKindDef（Pawn种类定义）
│   ├── RecipeDef（配方定义）
│   ├── ResearchProjectDef（科研项目定义）
│   ├── IncidentDef（事件定义）
│   ├── StatDef（属性定义）
│   ├── JobDef（行为定义）
│   ├── ThoughtDef（想法定义）
│   ├── TraitDef（特性定义）
│   └── ...（170+种Def子类）
```

#### Def基类核心字段

| 字段 | 类型 | 说明 |
|------|------|------|
| `defName` | string | 唯一标识符（XML中的`<defName>`），默认"UnnamedDef" |
| `label` | string | 玩家可见的显示名称 |
| `description` | string | 详细描述文本 |
| `modExtensions` | List\<DefModExtension\> | 模组扩展数据列表（详见2.4） |
| `shortHash` | ushort | 短哈希（存档用，由ShortHashGiver分配） |
| `index` | ushort | 在DefDatabase中的索引 |
| `modContentPack` | ModContentPack | 来源模组 |
| `generated` | bool | 是否为隐含生成的Def |

#### Def基类核心方法

| 方法 | 触发时机 | 用途 |
|------|---------|------|
| `PostLoad()` | XML反序列化完成后 | 后处理（如ThingDef初始化GraphicData） |
| `ResolveReferences()` | DefDatabase构建阶段 | 解析Def间交叉引用 |
| `ConfigErrors()` | DevMode错误检查 | 返回配置错误列表 |
| `GetModExtension<T>()` | 运行时 | 获取指定类型的DefModExtension |

#### DefDatabase\<T\>：泛型Def数据库

每种Def类型有独立的`DefDatabase<T>`实例，内部维护两个索引：

```csharp
private static List<T> defsList;                    // 有序列表（按index）
private static Dictionary<string, T> defsByName;    // defName → Def映射
```

**核心API**：

| 方法 | 用途 |
|------|------|
| `DefDatabase<T>.GetNamed(defName)` | 按defName查询（找不到报错） |
| `DefDatabase<T>.GetNamedSilentFail(defName)` | 按defName查询（找不到返回null） |
| `DefDatabase<T>.AllDefs` | 遍历所有该类型Def |
| `DefDatabase<T>.DefCount` | 该类型Def总数 |
| `DefDatabase<T>.GetByShortHash(hash)` | 按短哈希查询（存档加载用） |

**注册流程**：`AddAllInMods()`按模组LoadOrder遍历，后加载的模组可覆盖同名Def（同defName时移除旧的、添加新的）。

#### DefOf静态引用模式

标记`[DefOf]`特性的静态类，其public static字段会在加载阶段自动绑定到对应Def：

```csharp
[DefOf]
public static class ThingDefOf
{
    public static ThingDef Human;           // 自动绑定defName="Human"的ThingDef
    public static ThingDef Steel;           // 自动绑定defName="Steel"的ThingDef

    [MayRequire("Ludeon.RimWorld.Biotech")]
    public static ThingDef Mech_Centipede;  // 仅Biotech激活时绑定

    [DefAlias("MeleeWeapon_Longsword")]
    public static ThingDef Longsword;       // 字段名≠defName时用别名
}
```

**绑定机制**（`DefOfHelper.RebindAllDefOfs()`）：
1. 扫描所有标记`[DefOf]`的类型（并行执行）
2. 遍历每个public static字段
3. 字段名（或`[DefAlias]`指定的名称）作为defName查询DefDatabase
4. `[MayRequire]`/`[MayRequireAnyOf]`：对应模组未激活时跳过（不报错）
5. 绑定分两轮：earlyTry（静默）和 final（报错）

**使用注意**：
- DefOf字段在`Mod`构造函数中为null（尚未绑定），在`[StaticConstructorOnStartup]`中可用
- 不要在Def字段默认值中使用DefOf（Def加载时DefOf尚未绑定）
- 应在`ResolveReferences()`中解析Def引用

#### 常用Def类型速查表

| Def类型 | 命名空间 | 定义对象 | 对应实例类 | 模组常用度 |
|---------|---------|---------|-----------|-----------|
| **ThingDef** | Verse | 物品/建筑/Pawn/投射物 | Thing及子类 | ★★★★★ |
| **HediffDef** | Verse | 健康状态/伤口/疾病 | Hediff及子类 | ★★★★★ |
| **GeneDef** | Verse | 基因 | Gene及子类 | ★★★★ |
| **AbilityDef** | RimWorld | 能力 | Ability | ★★★★ |
| **StatDef** | RimWorld | 属性（移速/伤害等） | — | ★★★★ |
| **RecipeDef** | Verse | 配方/手术 | — | ★★★★ |
| **ResearchProjectDef** | Verse | 科研项目 | — | ★★★ |
| **FactionDef** | RimWorld | 派系 | Faction | ★★★ |
| **PawnKindDef** | Verse | Pawn种类/变体 | —（生成参数） | ★★★ |
| **IncidentDef** | RimWorld | 事件 | — | ★★★ |
| **JobDef** | Verse | 行为定义 | Job | ★★★ |
| **ThoughtDef** | RimWorld | 想法/心情 | Thought | ★★★ |
| **TraitDef** | RimWorld | 特性 | Trait | ★★ |
| **DamageDef** | Verse | 伤害类型 | — | ★★ |
| **EffecterDef** | Verse | 视觉效果编排 | Effecter | ★★ |
| **SoundDef** | Verse | 音效 | — | ★★ |
| **WorldObjectDef** | RimWorld | 世界地图对象 | WorldObject | ★★ |
| **TerrainDef** | Verse | 地形 | — | ★ |
| **BiomeDef** | RimWorld | 生态群系 | — | ★ |

**详细素材**：
- → `快速参考/Def类型总览与DefDatabase机制.md`（完整170+种Def分类、DefDatabase内部机制、DefOf模式详解）

### 2.2 XML配置系统 ✅

**核心类**：`Verse.DirectXmlToObject`（反序列化）、`Verse.XmlInheritance`（继承解析）。

#### XML文件加载路径

模组的Def文件放在`Defs/`目录下，**子目录结构和文件名不影响加载**——游戏递归扫描所有`.xml`文件。文件名和目录名仅用于人类组织，不影响Def注册。

```
MyMod/
├── Defs/
│   ├── ThingDefs/           ← 目录名随意，仅为组织
│   │   ├── Weapons.xml      ← 文件名随意
│   │   └── Buildings.xml
│   ├── HediffDefs/
│   │   └── MyHediffs.xml
│   └── Misc.xml             ← 可以混放不同类型的Def
```

**版本目录**：`1.5/Defs/`目录下的文件仅在对应游戏版本加载，优先于根`Defs/`。

#### XML到Def的反序列化流程

```
XML文件 → LoadModXML() → CombineIntoUnifiedXML() → ApplyPatches()
                                                         ↓
                                              XmlInheritance.Resolve()
                                                         ↓
                                              ParseAndProcessXML()
                                                         ↓
                                              DirectXmlToObject.ObjectFromXml<T>()
                                                         ↓
                                              Def对象（字段已填充，但Def引用尚未解析）
                                                         ↓
                                              DefDatabase<T>.AddAllInMods()
                                                         ↓
                                              DirectXmlCrossRefLoader.ResolveAllWantedCrossReferences()
                                                         ↓
                                              DefDatabase<T>.ResolveAllReferences()
```

#### DirectXmlToObject反序列化规则

`ObjectFromXml<T>()`的字段映射逻辑（按源码顺序）：

| XML内容 | C#字段类型 | 处理方式 |
|---------|-----------|---------|
| 纯文本节点 | 基本类型/枚举/string | `ParseHelper.FromString<T>()` 直接解析 |
| 纯文本节点 | Def子类 | **延迟解析**：注册到`DirectXmlCrossRefLoader`，后续批量解析 |
| 子节点列表 | `List<T>` | 递归调用`ListFromXml<T>()` |
| 子节点列表 | `Dictionary<K,V>` | 递归调用`DictionaryFromXml<K,V>()` |
| 子节点列表 | `[Flags]`枚举 | 解析为列表后按位OR合并 |
| 子节点 | 复合对象 | 递归调用`ObjectFromXml<T>()`（支持嵌套） |
| `Class="..."` 属性 | 多态类型 | 使用指定的子类型实例化 |
| `IsNull="true"` 属性 | 任意 | 设为null |

**关键细节**：
- 同一XML节点中**不允许重复字段名**（会报错）
- Def类型字段通过defName字符串引用，**不内联定义**
- `Class`属性支持多态：`<li Class="CompProperties_Glower">` 指定具体子类

#### 字段类型映射示例

```xml
<!-- 基本类型 -->
<stackLimit>75</stackLimit>                    <!-- int -->
<useHitPoints>true</useHitPoints>              <!-- bool -->
<fillPercent>0.5</fillPercent>                 <!-- float -->
<label>钢铁</label>                            <!-- string -->

<!-- 枚举 -->
<category>Item</category>                      <!-- ThingCategory枚举 -->
<techLevel>Industrial</techLevel>              <!-- TechLevel枚举 -->

<!-- Def引用（延迟解析） -->
<defaultStuff>WoodLog</defaultStuff>           <!-- ThingDef引用，值为defName -->
<filthLeaving>Filth_RubbleBuilding</filthLeaving>

<!-- 列表 -->
<thingCategories>
  <li>ResourcesRaw</li>                       <!-- List<ThingCategoryDef> -->
</thingCategories>

<!-- 嵌套复合对象 -->
<graphicData>                                  <!-- GraphicData对象 -->
  <texPath>Things/Item/Resource/Steel</texPath>
  <graphicClass>Graphic_StackCount</graphicClass>
</graphicData>

<!-- 多态列表（Class属性指定子类） -->
<comps>
  <li Class="CompProperties_Forbiddable"/>     <!-- 无额外字段 -->
  <li Class="CompProperties_Glower">           <!-- 有额外字段 -->
    <glowRadius>5</glowRadius>
    <glowColor>(255,200,100,0)</glowColor>
  </li>
</comps>

<!-- StatModifier列表（特殊格式：标签名=StatDef.defName，值=数值） -->
<statBases>
  <MaxHitPoints>100</MaxHitPoints>
  <MarketValue>1.9</MarketValue>
</statBases>

<!-- MayRequire条件引用 -->
<comps>
  <li Class="CompProperties_Drug" MayRequire="Ludeon.RimWorld.Biotech">
    <!-- 仅Biotech激活时加载 -->
  </li>
</comps>
```

#### ParentName继承机制

`XmlInheritance`实现XML级别的模板继承，在反序列化之前完成节点合并：

```xml
<!-- 定义抽象模板（Abstract="True"不会生成实际Def） -->
<ThingDef ParentName="BaseWeapon" Abstract="True" Name="BaseMeleeWeapon">
  <thingClass>ThingWithComps</thingClass>
  <category>Item</category>
  <equipmentType>Primary</equipmentType>
  <techLevel>Medieval</techLevel>
</ThingDef>

<!-- 继承模板（ParentName引用父模板的Name） -->
<ThingDef ParentName="BaseMeleeWeapon">
  <defName>MeleeWeapon_Longsword</defName>
  <label>longsword</label>
  <techLevel>Medieval</techLevel>          <!-- 覆盖父级字段 -->
  <tools>                                  <!-- 子级独有字段 -->
    <li>...</li>
  </tools>
</ThingDef>
```

**继承解析规则**（`ResolveXmlNodeFor()`）：
1. 克隆父节点的完整XML
2. 子节点的字段**覆盖**父节点同名字段
3. 子节点独有的字段**追加**到结果中
4. 列表字段（如`<comps>`）默认**整体替换**，不合并
5. 支持多级继承（A → B → C），递归解析
6. `Name`属性用于被引用，`ParentName`属性用于引用父级
7. `Abstract="True"`的Def不注册到DefDatabase

**原版大量使用继承**：如`BaseHumanMakeableGun` → `BaseGun` → `BaseBullet`等，形成深层继承链。模组可继承原版模板。

**详细素材**：
- → `快速参考/XML配置系统与Def反序列化机制.md`（完整反序列化流程、字段类型映射、ParentName继承规则、MayRequire机制）

### 2.3 ThingDef详解 ✅

**继承链**：`ThingDef → BuildableDef → Def → Editable`

ThingDef是RimWorld中最复杂的Def类型，定义了物品、建筑、Pawn、投射物等几乎所有游戏实体。字段数量200+。

#### ThingDef核心字段分类

**基础标识**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `thingClass` | Type | 运行时实例的C#类型（默认Thing，可指定子类） |
| `category` | ThingCategory | 物品大类（Item/Building/Pawn/Projectile等） |
| `tickerType` | TickerType | Tick频率（Never/Normal/Rare/Long） |
| `stackLimit` | int | 堆叠上限（默认1） |
| `size` | IntVec2 | 占地尺寸（建筑用） |
| `useHitPoints` | bool | 是否有耐久度 |
| `selectable` | bool | 是否可选中 |
| `destroyable` | bool | 是否可销毁 |

**图形与渲染**（继承自BuildableDef + ThingDef扩展）：

| 字段 | 类型 | 说明 |
|------|------|------|
| `graphicData` | GraphicData | 图形配置（贴图路径/着色器/尺寸等） |
| `drawerType` | DrawerType | 渲染方式（MapMeshOnly/RealtimeOnly/MapMeshAndRealtime） |
| `altitudeLayer` | AltitudeLayer | 渲染层级（地面/物品/建筑/Pawn等） |
| `castEdgeShadows` | bool | 是否投射边缘阴影 |
| `staticSunShadowHeight` | float | 静态阳光阴影高度 |
| `colorGenerator` | ColorGenerator | 随机颜色生成器 |

**Comp组件列表**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `comps` | List\<CompProperties\> | Comp配置列表（XML中通过`Class`属性指定子类） |

**属性基础值**（继承自BuildableDef）：

| 字段 | 类型 | 说明 |
|------|------|------|
| `statBases` | List\<StatModifier\> | 基础属性值列表（MaxHitPoints/MarketValue/Mass等） |
| `equippedStatOffsets` | List\<StatModifier\> | 装备时的属性偏移 |

**建造相关**（继承自BuildableDef）：

| 字段 | 类型 | 说明 |
|------|------|------|
| `costList` | List\<ThingDefCountClass\> | 建造材料列表 |
| `costStuffCount` | int | 材质材料数量 |
| `stuffCategories` | List\<StuffCategoryDef\> | 可用材质类别 |
| `researchPrerequisites` | List\<ResearchProjectDef\> | 科研前置 |
| `designationCategory` | DesignationCategoryDef | 建筑菜单分类 |
| `placeWorkers` | List\<Type\> | 放置验证器列表 |

**嵌套属性类**（ThingDef通过嵌套对象组织大量专用字段）：

| 字段 | 类型 | 适用场景 |
|------|------|---------|
| `building` | BuildingProperties | 建筑专用（自动修复/电力/交互点等） |
| `race` | RaceProperties | Pawn专用（智力/体型/食性/BodyDef等） |
| `apparel` | ApparelProperties | 衣物专用（层级/覆盖部位/标签等） |
| `ingestible` | IngestibleProperties | 可食用物专用（营养/效果/声音等） |
| `projectile` | ProjectileProperties | 投射物专用（伤害/速度/爆炸等） |
| `plant` | PlantProperties | 植物专用（生长/产出/野生等） |
| `stuffProps` | StuffProperties | 材质专用（颜色/属性修正等） |
| `skyfaller` | SkyfallerProperties | 天降物专用（速度/动画/阴影等） |
| `filth` | FilthProperties | 污物专用 |
| `gas` | GasProperties | 气体专用 |
| `mote` | MoteProperties | Mote粒子专用 |
| `recipeMaker` | RecipeMakerProperties | 自动生成配方（如"制作长剑"） |

#### ThingCategory枚举

| 值 | 说明 | 典型thingClass |
|----|------|---------------|
| `Item` | 物品（武器/资源/食物/衣物等） | Thing / ThingWithComps |
| `Building` | 建筑（墙壁/工作台/家具等） | Building / Building_WorkTable |
| `Pawn` | 生物（人类/动物/机械体） | Pawn |
| `Projectile` | 投射物（子弹/箭矢） | Projectile / Bullet |
| `Plant` | 植物 | Plant |
| `Filth` | 污物 | Filth |
| `Gas` | 气体 | Gas |
| `Mote` | 视觉粒子 | Mote |
| `Ethereal` | 虚体（区域等） | — |
| `Attachment` | 附着物（火焰等） | — |

#### thingClass字段与自定义Thing子类

`thingClass`决定运行时创建的C#实例类型。原版常用的Thing子类：

```
Thing（基类）
├── ThingWithComps（支持Comp的Thing）★ 最常用
│   ├── Building（建筑基类）
│   │   ├── Building_WorkTable（工作台）
│   │   ├── Building_Door（门）
│   │   ├── Building_Storage（仓储区）
│   │   ├── Building_Turret（炮塔基类）
│   │   └── Building_Bed（床）
│   ├── Pawn（生物）
│   ├── Apparel（衣物）
│   ├── MinifiedThing（打包物品）
│   └── Corpse（尸体）
├── Projectile（投射物基类）
│   └── Bullet（子弹）
├── Plant（植物）
├── Filth（污物）
├── Gas（气体）
├── Mote（视觉粒子基类）
└── Fire（火焰）
```

**模组自定义thingClass**：当Comp无法满足需求时，可创建自定义Thing子类并在XML中指定：
```xml
<ThingDef>
  <thingClass>MyMod.MyCustomBuilding</thingClass>
  <!-- ... -->
</ThingDef>
```
但**优先使用Comp**，因为Comp更模块化、更不容易与其他模组冲突。

**已有素材**：
- → `快速参考/物品分类与堆叠系统.md`（ThingCategory与堆叠机制）
- → `快速参考/建筑类型分类与DesignationCategory体系.md`（建筑ThingDef配置）

### 2.4 DefModExtension扩展机制 ✅

**核心类**：`Verse.DefModExtension`，极简基类（仅有`ConfigErrors()`和`ResolveReferences()`两个虚方法）。

#### 用途

为**已有Def类型**附加自定义数据字段，无需修改Def类本身。所有Def基类都有`modExtensions`字段，因此任何Def类型都可以附加。

#### 定义方式

**C#侧**：创建`DefModExtension`子类，定义自定义字段：

```csharp
public class MyModExtension : DefModExtension
{
    public float trionCost = 10f;
    public bool canTransform = false;
    public List<string> allowedModes;

    // 可选：配置错误检查
    public override IEnumerable<string> ConfigErrors()
    {
        if (trionCost < 0) yield return "trionCost不能为负数";
    }
}
```

**XML侧**：在任意Def的`<modExtensions>`列表中添加：

```xml
<ThingDef>
  <defName>MyWeapon</defName>
  <!-- ... 其他字段 ... -->
  <modExtensions>
    <li Class="MyMod.MyModExtension">
      <trionCost>25</trionCost>
      <canTransform>true</canTransform>
      <allowedModes>
        <li>Combat</li>
        <li>Stealth</li>
      </allowedModes>
    </li>
  </modExtensions>
</ThingDef>
```

#### 查询方式

```csharp
// 获取（找不到返回null）
MyModExtension ext = def.GetModExtension<MyModExtension>();
if (ext != null)
{
    float cost = ext.trionCost;
}

// 检查是否存在
bool has = def.HasModExtension<MyModExtension>();
```

**实现原理**：遍历`modExtensions`列表，用`is T`类型检查匹配。列表通常很短（0-3个），性能无忧。

#### 适用场景 vs 不适用场景

| 场景 | 推荐方案 | 原因 |
|------|---------|------|
| 为已有Def附加静态数据 | ✅ DefModExtension | 无需修改Def类，XML可配置 |
| 为已有Def附加运行时逻辑 | ❌ 用Comp | DefModExtension无Tick/存档能力 |
| 定义全新的Def类型 | ❌ 创建Def子类 | DefModExtension是附加数据，不是新类型 |
| 修改原版Def的行为 | ✅ DefModExtension + XPath | 通过Patch给原版Def添加扩展数据 |
| 需要运行时状态 | ❌ 用Comp | DefModExtension是Def级（静态），不是实例级 |

**核心区别**：DefModExtension是**Def级别的静态数据**（所有实例共享），Comp是**实例级别的运行时数据**（每个实例独立）。

### 2.5 Def交叉引用与依赖 ✅

**核心类**：`Verse.DirectXmlCrossRefLoader`（延迟引用注册与解析）。

#### Def之间的引用方式

Def之间通过**defName字符串**互相引用，而非直接对象引用。原因：XML反序列化时，被引用的Def可能尚未加载。

```xml
<ThingDef>
  <defName>MeleeWeapon_Longsword</defName>
  <defaultStuff>Steel</defaultStuff>           <!-- 引用另一个ThingDef -->
  <filthLeaving>Filth_RubbleBuilding</filthLeaving>  <!-- 引用另一个ThingDef -->
  <stuffCategories>
    <li>Metallic</li>                          <!-- 引用StuffCategoryDef -->
  </stuffCategories>
</ThingDef>
```

#### 延迟解析机制（两阶段）

`DirectXmlToObject.ObjectFromXml<T>()`在反序列化时，遇到Def类型字段**不立即解析**，而是注册到`DirectXmlCrossRefLoader`：

```csharp
// ObjectFromXml中的关键逻辑：
if (GenTypes.IsDef(fieldInfo.FieldType))
{
    // 不立即解析，注册"想要引用"
    DirectXmlCrossRefLoader.RegisterObjectWantsCrossRef(
        val,                    // 持有引用的对象
        fieldInfo,              // 字段信息
        xmlNode.InnerText,      // defName字符串
        mayRequire,             // 可选：MayRequire模组ID
        mayRequireAnyOf         // 可选：MayRequireAnyOf模组ID列表
    );
    continue;  // 跳过正常赋值
}
```

**解析时机**（在`PlayDataLoader.DoPlayLoad()`中）：

```
阶段1：所有XML解析完毕，Def对象已创建但引用字段为null
    ↓
DirectXmlCrossRefLoader.ResolveAllWantedCrossReferences(FailMode.Silent)
    — 第一轮：静默模式，找不到不报错（因为隐含Def尚未生成）
    ↓
DefGenerator.GenerateImpliedDefs_PreResolve()
    — 生成隐含Def（如肉/皮革/蓝图/框架等）
    ↓
DirectXmlCrossRefLoader.ResolveAllWantedCrossReferences(FailMode.LogErrors)
    — 第二轮：报错模式，此时所有Def应已就绪
    ↓
DefDatabase<T>.ResolveAllReferences()
    — 调用每个Def的ResolveReferences()方法
```

#### ResolveReferences()生命周期

`Def.ResolveReferences()`在所有交叉引用解析完毕后调用，用于：
1. 缓存频繁访问的引用
2. 构建反向索引
3. 验证引用完整性
4. 初始化派生数据

**调用顺序有讲究**（`PlayDataLoader`中硬编码）：
1. `ThingCategoryDef`（优先，并行）— 因为很多Def引用分类
2. `RecipeDef`（优先，并行）— 因为ThingDef.AllRecipes依赖它
3. 其他Def类型
4. `ThingDef`（最后）— 因为依赖最多其他Def

#### MayRequire条件引用

XML中的`MayRequire`属性支持**可选依赖**——引用的Def来自可能未安装的模组/DLC：

```xml
<!-- 字段级条件引用 -->
<defaultStuff MayRequire="Ludeon.RimWorld.Biotech">ArchitePlasma</defaultStuff>

<!-- 列表项条件引用 -->
<comps>
  <li Class="CompProperties_Drug" MayRequire="Ludeon.RimWorld.Royalty">
    <chemical>Psychite</chemical>
  </li>
</comps>
```

对应模组未激活时，该引用被静默跳过（不报错、不赋值）。

#### 模组开发注意事项

1. **不要在Def字段默认值中引用其他Def**：Def构造时其他Def可能不存在
2. **使用ResolveReferences()做后处理**：此时所有Def和交叉引用已就绪
3. **PostLoad() vs ResolveReferences()**：
   - `PostLoad()`：XML反序列化后立即调用，Def引用字段仍为null
   - `ResolveReferences()`：所有交叉引用解析后调用，Def引用已就绪
4. **循环引用**：RimWorld不检测循环引用，但由于延迟解析机制，简单的A↔B互引用可以正常工作
5. **隐含Def**：肉/皮革/蓝图/框架等由`DefGenerator`自动生成，不在XML中定义，但可被其他Def引用

---

## 第3章 Comp组件系统 ⚠️ → ✅ 已整理

> **目标**：掌握RimWorld最核心的扩展机制
> **对应模组需求**：几乎所有自定义实体都需要Comp

### 3.1 ThingComp体系 ✅ 已整理

**核心分离**：`CompProperties`（XML数据层，定义配置参数）与 `ThingComp`（运行时逻辑层，执行行为）。一个ThingDef的`comps`列表中配置CompProperties，游戏运行时为每个Thing实例创建对应的ThingComp。

**继承链**：`ThingComp` 直接继承自 `object`，实现了大量虚方法供子类重写。

#### 生命周期回调（按调用顺序）

| 回调方法 | 触发时机 | 常见用途 |
|---------|---------|---------|
| `Initialize(props)` | Comp创建时 | 初始化props引用 |
| `PostPostMake()` | Thing.PostMake之后 | 初始化运行时数据 |
| `PostSpawnSetup(respawningAfterLoad)` | Thing放置到地图时 | 注册到管理器、启动效果 |
| `CompTick()` / `CompTickRare()` / `CompTickLong()` | 每Tick/250Tick/2000Tick | 周期性逻辑 |
| `PostExposeData()` | 存档保存/加载 | 序列化自定义字段 |
| `PostPreApplyDamage(dinfo, absorbed)` | 受伤前 | 伤害拦截（如护盾） |
| `PostPostApplyDamage(dinfo, totalDamage)` | 受伤后 | 伤害响应 |
| `PostDeSpawn(map, mode)` | 从地图移除时 | 清理注册 |
| `PostDestroy(mode, previousMap)` | 销毁时 | 最终清理 |

#### 关键交互回调

| 回调方法 | 用途 |
|---------|------|
| `CompGetGizmosExtra()` | 注入Gizmo命令按钮 |
| `CompGetWornGizmosExtra()` | 穿戴时注入Gizmo |
| `Notify_Equipped/Unequipped(pawn)` | 装备/卸下通知 |
| `Notify_Killed(map, dinfo)` | 持有者死亡通知 |
| `ReceiveCompSignal(signal)` | 接收字符串信号（Comp间通信） |
| `CompRenderNodes()` | 注入自定义渲染节点 |
| `GetStatFactor/GetStatOffset(stat)` | 提供Stat修正 |

#### 常用原版ThingComp分类速查

| 分类 | 代表Comp | 职责 |
|------|---------|------|
| **电力** | CompPower(→CompPowerTrader/CompPowerPlant/CompPowerBattery) | 供电/耗电/储电 |
| **燃料** | CompRefuelable | 燃料消耗与补充 |
| **品质** | CompQuality | 物品品质等级 |
| **武器** | CompEquippable | 武器Verb管理 |
| **护盾** | CompShield / CompProjectileInterceptor | 伤害拦截 |
| **爆炸** | CompExplosive | 爆炸触发 |
| **腐烂** | CompRottable | 食物腐烂 |
| **生成** | CompSpawner / CompSpawnerPawn | 周期性生成物品/Pawn |
| **运输** | CompTransporter / CompShuttle / CompLaunchable | 运输/穿梭机/发射 |
| **设施** | CompFacility / CompAffectedByFacilities | 建筑设施加成 |
| **交互** | CompUsable / CompInteractable | 使用/交互行为 |
| **视觉** | CompGlower / CompFireOverlayBase / CompFleckEmitter | 发光/火焰/粒子 |
| **开关** | CompFlickable / CompBreakdownable | 开关/故障 |
| **DLC** | CompBiosculpterPod / CompBandNode / CompActivity | 各DLC专属功能 |

#### 自定义ThingComp创建流程

1. 定义 `CompProperties_Xxx : CompProperties`（XML配置字段）
2. 定义 `CompXxx : ThingComp`（运行时逻辑）
3. 在CompProperties构造函数中设置 `compClass = typeof(CompXxx)`
4. XML中在ThingDef的`<comps>`列表添加配置

**参考素材**：
- → `快速参考/建筑供电系统.md`（CompPowerTrader详解）
- → `快速参考/品质系统.md`（CompQuality相关）

### 3.2 HediffComp体系 ✅ 已整理

**核心分离**：与ThingComp同理——`HediffCompProperties`（XML配置）与 `HediffComp`（运行时逻辑）。HediffComp附加在`HediffWithComps`实例上。

#### 生命周期回调

| 回调方法 | 触发时机 | 常见用途 |
|---------|---------|---------|
| `CompPostMake()` | Hediff创建时 | 初始化 |
| `CompPostPostAdd(dinfo)` | Hediff添加到Pawn后 | 添加后效果 |
| `CompPostTick(severityAdjustment)` | 每Tick | 周期性逻辑（Severity变化等） |
| `CompExposeData()` | 存档 | 序列化 |
| `CompPostMerged(other)` | 同类Hediff合并时 | 合并处理 |
| `CompTended(quality, maxQuality, pos)` | 被治疗时 | 治疗响应 |
| `CompPostPostRemoved()` | Hediff移除后 | 清理 |
| `Notify_PawnDied(dinfo, culprit)` | Pawn死亡时 | 死亡响应 |
| `Notify_PawnPostApplyDamage(dinfo, total)` | Pawn受伤后 | 伤害响应 |
| `CompGetGizmos()` | UI | 注入Gizmo |

#### 关键区别：ThingComp vs HediffComp

| 维度 | ThingComp | HediffComp |
|------|-----------|------------|
| 附加对象 | Thing（物品/建筑/Pawn） | HediffWithComps（健康状态） |
| 父引用 | `parent`（ThingWithComps） | `parent`（HediffWithComps），`Pawn`属性 |
| Tick方法 | `CompTick()` 无参数 | `CompPostTick(float severityAdjustment)` 带Severity调整参数 |
| 配置位置 | ThingDef.comps | HediffDef.comps |

**已有素材**：
- → `快速参考/Hediff互相影响与触发机制.md`（HediffComp列表和触发模式）
- → `快速参考/Severity严重程度机制.md`（HediffComp_SeverityPerDay等）

### 3.3 其他Comp体系 ✅ 已整理

RimWorld在不同层级都有Comp模式，形成统一的组件化扩展体系：

| 层级 | Comp基类 | Properties基类 | 附加对象 | 适用场景 |
|------|---------|---------------|---------|---------|
| **Thing级** | ThingComp | CompProperties | 物品/建筑/Pawn | 单个实体的行为扩展 |
| **Hediff级** | HediffComp | HediffCompProperties | 健康状态 | 状态效果扩展 |
| **WorldObject级** | WorldObjectComp | WorldObjectCompProperties | 世界地图对象 | 世界对象行为扩展 |
| **Map级** | MapComponent | —（直接字段） | 地图 | 地图级全局数据/逻辑 |
| **Game级** | GameComponent | —（直接字段） | 游戏实例 | 跨地图全局数据/逻辑 |

#### WorldObjectComp

附加在WorldObject上（如定居点、远行队、遗迹等），生命周期回调：
- `Initialize(props)` / `CompTick()` / `PostExposeData()`
- `GetGizmos()` / `GetFloatMenuOptions(caravan)` / `GetCaravanGizmos(caravan)`
- `PostMapGenerate()` / `PostMyMapRemoved()` / `PostCaravanFormed(caravan)`

#### MapComponent

地图级单例组件，每个Map实例持有一组MapComponent。**不通过XML配置**，而是在C#中直接注册。
- 回调：`MapComponentTick()` / `MapComponentUpdate()` / `MapComponentOnGUI()` / `MapComponentDraw()`
- 存档：`ExposeData()`
- 初始化：`FinalizeInit()` / `MapGenerated()`

#### GameComponent

游戏级单例组件，整个Game实例持有一组GameComponent。同样不通过XML配置。
- 回调：`GameComponentTick()` / `GameComponentUpdate()` / `GameComponentOnGUI()`
- 存档：`ExposeData()`
- 初始化：`FinalizeInit()` / `StartedNewGame()` / `LoadedGame()`

#### 选择指南

- 需要附加到特定物品/建筑 → **ThingComp**
- 需要附加到Pawn健康状态 → **HediffComp**
- 需要附加到世界地图对象 → **WorldObjectComp**
- 需要地图级全局数据（如自定义天气系统）→ **MapComponent**
- 需要跨地图全局数据（如全局计数器）→ **GameComponent**

### 3.4 Comp间通信与协作 ✅ 已整理

**同一Thing上多个Comp的交互方式**：

1. **直接查询**：`parent.GetComp<CompXxx>()` — 获取同一Thing上的其他Comp
2. **信号广播**：`ReceiveCompSignal(string signal)` — 字符串信号机制，如"FlickedOn"/"FlickedOff"/"RanOutOfFuel"等
3. **Notify回调**：`Notify_xxx()` 系列方法 — 特定事件通知（如Notify_Equipped、Notify_Killed等）
4. **Stat系统**：`GetStatFactor/GetStatOffset` — 通过Stat系统间接影响其他Comp的行为

---

## 第4章 Pawn系统技术架构 ✅ [已有素材]

> **目标**：理解Pawn作为最复杂游戏对象的技术结构
> **对应模组需求**：战斗体状态切换、Trion资源、触发器装备

### 4.1 Pawn类结构 ⚠️ → ✅ 已整理

**继承链**：`Pawn → ThingWithComps → Thing → Entity`

Pawn是RimWorld中最复杂的游戏对象，通过40+个Tracker字段管理各子系统。按功能分类如下：

#### 核心子系统Tracker

| 字段 | 类型 | 职责 |
|------|------|------|
| `health` | Pawn_HealthTracker | 健康/Hediff/伤害管理 |
| `needs` | Pawn_NeedsTracker | 需求系统（食物/心情/休息等） |
| `jobs` | Pawn_JobTracker | 行为调度（当前Job/Job队列） |
| `mindState` | Pawn_MindState | 心理状态（敌意/恐惧/目标记忆） |
| `thinker` | Pawn_Thinker | 决策树（ThinkTree入口） |
| `stances` | Pawn_StanceTracker | 姿态管理（站立/瞄准/击晕） |

#### 身份与故事

| 字段 | 类型 | 职责 |
|------|------|------|
| `kindDef` | PawnKindDef | 种类定义（与ThingDef分离，控制生成参数） |
| `nameInt` | Name | 名字（NameSingle/NameTriple） |
| `gender` | Gender | 性别 |
| `story` | Pawn_StoryTracker | 背景故事/体型/头型/发型/肤色（仅Humanlike） |
| `ageTracker` | Pawn_AgeTracker | 年龄/生长阶段 |
| `records` | Pawn_RecordsTracker | 统计记录（击杀数等） |

#### 装备与物品

| 字段 | 类型 | 职责 |
|------|------|------|
| `equipment` | Pawn_EquipmentTracker | 主武器 |
| `apparel` | Pawn_ApparelTracker | 衣物/护甲 |
| `inventory` | Pawn_InventoryTracker | 背包物品 |
| `carryTracker` | Pawn_CarryTracker | 手持搬运物 |

#### 战斗

| 字段 | 类型 | 职责 |
|------|------|------|
| `meleeVerbs` | Pawn_MeleeVerbs | 近战Verb管理 |
| `verbTracker` | VerbTracker | 通用Verb追踪 |
| `natives` | Pawn_NativeVerbs | 原生Verb（如动物撕咬） |
| `drafter` | Pawn_DraftController | 征召控制 |

#### 社交与派系

| 字段 | 类型 | 职责 |
|------|------|------|
| `relations` | Pawn_RelationsTracker | 人际关系 |
| `interactions` | Pawn_InteractionsTracker | 社交互动 |
| `guest` | Pawn_GuestTracker | 囚犯/客人状态 |
| `guilt` | Pawn_GuiltTracker | 罪恶感追踪 |

#### 技能与工作

| 字段 | 类型 | 职责 |
|------|------|------|
| `skills` | Pawn_SkillTracker | 技能等级（仅Humanlike） |
| `workSettings` | Pawn_WorkSettings | 工作优先级设置 |
| `training` | Pawn_TrainingTracker | 动物训练 |

#### DLC专属Tracker

| 字段 | 类型 | DLC | 职责 |
|------|------|-----|------|
| `royalty` | Pawn_RoyaltyTracker | Royalty | 皇室头衔/许可 |
| `abilities` | Pawn_AbilityTracker | Core+DLC | 能力管理 |
| `psychicEntropy` | Pawn_PsychicEntropyTracker | Royalty | 心灵熵/Psyfocus |
| `ideo` | Pawn_IdeoTracker | Ideology | 意识形态 |
| `style` | Pawn_StyleTracker | Ideology | 风格偏好 |
| `genes` | Pawn_GeneTracker | Biotech | 基因系统 |
| `mechanitor` | Pawn_MechanitorTracker | Biotech | 机械师/带宽 |
| `learning` | Pawn_LearningTracker | Biotech | 婴幼儿学习 |
| `mutant` | Pawn_MutantTracker | Anomaly | 变异体 |
| `creepjoiner` | Pawn_CreepJoinerTracker | Anomaly | 诡异加入者 |
| `infectionVectors` | Pawn_InfectionVectorTracker | Anomaly | 感染载体 |
| `duplicate` | Pawn_DuplicateTracker | Anomaly | 复制体 |

#### 移动与渲染

| 字段 | 类型 | 职责 |
|------|------|------|
| `pather` | Pawn_PathFollower | 寻路/移动 |
| `rotationTracker` | Pawn_RotationTracker | 朝向 |
| `drawer` | Pawn_DrawTracker | 渲染管理（PawnRenderTree入口） |
| `flight` | Pawn_FlightTracker | 飞行状态 |

#### PawnKindDef vs ThingDef

- `ThingDef`：定义Pawn的"物种"（人类/动物/机械体），控制基础属性、身体结构、RaceProperties
- `PawnKindDef`：定义Pawn的"变体"（海盗/商人/灰熊幼崽），控制生成参数（装备/技能范围/战斗力）
- 一个ThingDef可对应多个PawnKindDef（如Human对应Colonist/Pirate/Trader等）

**参考素材**：
- → `快速参考/机械体与普通Pawn系统差异.md`（Pawn字段对比）
- → `快速参考/敌对派系与玩家Pawn系统差异.md`（Pawn配置差异）
- → `快速参考/派系Pawn特征与生成机制.md`（PawnKindDef相关）

### 4.2 健康系统技术架构 ✅

**概述**：健康系统是Pawn最复杂的子系统，由Pawn_HealthTracker统管，核心数据结构为HediffSet。伤害处理经过DamageWorker→ArmorUtility→Hediff创建的完整管线。

**已有素材**（按阅读顺序）：
1. → `快速参考/Hediff分类与继承体系.md` — Hediff完整C#继承树、8大功能分类、HediffDef关键字段
2. → `快速参考/Severity严重程度机制.md` — Severity变化机制、阈值效果
3. → `快速参考/Hediff互相影响与触发机制.md` — HediffComp触发链、Hediff间交互
4. → `快速参考/身体部位与伤害分配系统.md` — BodyDef树形结构、命中部位选择
5. → `快速参考/伤害类型分类与DamageDef体系.md` — DamageDef分类、DamageWorker
6. → `快速参考/战斗伤害管线完整流程.md` — 完整伤害处理代码路径
7. → `快速参考/伤害减免机制总览.md` — ArmorUtility、护甲计算
8. → `快速参考/护盾机制与伤害吸收系统.md` — CompShield、伤害拦截
9. → `快速参考/植入体效果机制.md` — Hediff_Implant/AddedPart技术实现
10. → `快速参考/Pawn死亡判定与致死方式.md` — 死亡判定代码路径
11. → `快速参考/死亡事件后续效果链.md` — 死亡后触发的事件链
12. → `快速参考/战斗极端情况与安全网机制.md` — 边界情况处理

**补充素材**：
- → `快速参考/Trait特性系统与Hediff对比.md` — Trait vs Hediff的技术差异

### 4.3 需求与资源系统技术架构 ✅

**概述**：需求系统由Pawn_NeedsTracker管理，每个Need子类按NeedInterval(150 ticks)更新。资源型需求（如Hemogen、Psyfocus）通过Gene_Resource和IGeneResourceDrain接口实现。

**已有素材**：
1. → `快速参考/Need需求系统总览.md` — Need子类继承树、NeedInterval机制、自定义Need注册
2. → `快速参考/Need极端值效果与精神崩溃系统.md` — 极端值触发、MentalBreaker
3. → `快速参考/代谢效率与Biostat系统.md` — Gene_Resource、biostatMet/biostatCpx

**补充素材**：
- → `快速参考/机械师系统与带宽控制体系.md` — MechanitorTracker作为自定义Tracker的参考

### 4.4 基因系统技术架构 ✅

**概述**：基因系统由Pawn_GeneTracker管理，分Xenogenes/Endogenes两组。GeneDef通过多种路径产生效果：StatOffset/StatFactor、Ability授予、Hediff附加、资源消耗等。

**已有素材**：
1. → `快速参考/基因系统结构与继承体系.md` — Pawn_GeneTracker、Gene子类继承树
2. → `快速参考/基因效果分类与实现机制.md` — 基因效果的6种实现路径
3. → `快速参考/基因获得与移除途径.md` — 基因增删的代码路径
4. → `快速参考/模组自定义基因与扩展模式.md` — 自定义Gene子类的创建流程

### 4.5 装备系统技术架构 ✅

**概述**：装备分两个Tracker管理——Pawn_EquipmentTracker（主武器）和Pawn_ApparelTracker（衣物）。衣物通过ApparelLayerDef和BodyPartGroupDef实现层级穿戴系统。

**已有素材**：
1. → `快速参考/装备大类与穿戴规则.md` — ApparelLayerDef、BodyPartGroupDef、穿戴冲突
2. → `快速参考/装备属性叠加计算.md` — EquippedStatOffsets、StatModifier计算链
3. → `快速参考/装备插槽与组件系统.md` — 装备Comp体系
4. → `快速参考/装备视觉表现与渲染机制.md` — 装备渲染节点
5. → `快速参考/品质系统.md` — CompQuality、品质对属性的影响

### 4.6 能力系统技术架构 ✅

**概述**：能力系统采用AbilityDef→Ability→AbilityComp三层架构，由Pawn_AbilityTracker管理。效果通过CompAbilityEffect子类实现，触发流程为Activate→Cast→Effect。

**已有素材**：
1. → `快速参考/Ability系统基本结构.md` — 三层架构、AbilityDef字段表、CompAbilityEffect继承树、施放流程
2. → `快速参考/各DLC能力实例与分类.md` — 原版能力实例分析
3. → `快速参考/能力与特性关联机制.md` — 能力授予路径

---

## 第5章 AI与行为系统技术架构 ✅ [已整理]

> **目标**：理解Pawn行为控制的代码实现
> **对应模组需求**：战斗体激活/解除行为、Trion兵AI、触发器使用行为

### 5.1 Job系统 ✅

**概述**：Job系统是五层架构——ThinkTree(决策)→JobGiver(生成)→Job(数据)→JobDriver(执行)→Toil(原子)。Pawn_JobTracker作为调度器统一管理。

**已有素材**：
1. → `快速参考/Job系统架构与调度机制.md` — 五层架构详解、生命周期、ThinkTree结构、模组扩展点
2. → `快速参考/战斗Job与日常Job差异对比.md` — 战斗/日常Job的技术差异
3. → `快速参考/战斗行为与玩家命令系统.md` — 战斗相关Job和玩家命令

### 5.2 Lord系统（群体AI）✅ 已整理

**概述**：Lord是RimWorld的群体AI框架，管理一组Pawn的协同行为（如袭击、仪式、商队）。核心是状态机模式：`LordJob`定义整体行为图，`LordToil`定义当前状态，`Trigger`定义状态转换条件。

#### 三层架构

```
Lord（运行时管理器）
├── LordJob（行为定义，创建StateGraph）
│   └── StateGraph（状态图）
│       ├── LordToil_1（状态1：如集结）
│       │   └── UpdateAllDuties() → 为每个Pawn分配PawnDuty
│       ├── LordToil_2（状态2：如进攻）
│       ├── Transition（状态转换）
│       │   ├── Trigger（触发条件：如伤亡过半）
│       │   └── TransitionAction（转换动作：如发送信号）
│       └── ...
└── ownedPawns（管理的Pawn列表）
```

#### Lord核心字段

| 字段 | 类型 | 职责 |
|------|------|------|
| `curJob` | LordJob | 当前行为定义 |
| `curLordToil` | LordToil | 当前状态 |
| `graph` | StateGraph | 状态图 |
| `ownedPawns` | List\<Pawn\> | 管理的Pawn |
| `faction` | Faction | 所属派系 |

#### LordJob关键方法

| 方法 | 职责 |
|------|------|
| `CreateGraph()` | **核心**：创建StateGraph，定义所有LordToil和Transition |
| `LordJobTick()` | 每Tick逻辑 |
| `Notify_PawnLost(p, condition)` | Pawn丢失通知（死亡/逃跑等） |

#### LordToil关键方法

| 方法 | 职责 |
|------|------|
| `UpdateAllDuties()` | **核心**：为所有Pawn分配PawnDuty |
| `LordToilTick()` | 状态内每Tick逻辑 |
| `Init()` / `Cleanup()` | 进入/离开状态时的初始化/清理 |

#### 袭击Lord示例流程

`LordJob_AssaultColony.CreateGraph()` 创建的状态图大致为：
1. `LordToil_Stage`（集结点等待）→ 触发：到达集结点 → 转换到进攻
2. `LordToil_AssaultColony`（进攻殖民地）→ 触发：伤亡过半 → 转换到撤退
3. `LordToil_ExitMap`（撤退离开地图）

**参考素材**：
- → `快速参考/袭击流程与结束条件.md`（袭击Lord状态机）

### 5.3 Duty系统 ✅ 已整理

**概述**：PawnDuty是Lord分配给单个Pawn的行为指令。LordToil通过`UpdateAllDuties()`为每个Pawn设置Duty，Pawn的ThinkTree中有专门的ThinkNode检查当前Duty并生成对应Job。

#### PawnDuty核心字段

| 字段 | 类型 | 职责 |
|------|------|------|
| `def` | DutyDef | 职责定义（如DutyDefOf.AssaultColony） |
| `focus` | LocalTargetInfo | 主要目标位置 |
| `radius` | float | 活动半径 |
| `locomotion` | LocomotionUrgency | 移动紧迫度（Walk/Jog/Sprint） |
| `maxDanger` | Danger | 可接受的最大危险等级 |

#### Duty与Job的关系

```
Lord → LordToil.UpdateAllDuties() → 为Pawn设置PawnDuty
                                          ↓
Pawn.ThinkTree → ThinkNode_Duty → 根据Duty.def查找对应ThinkNode
                                          ↓
                                   JobGiver → 生成具体Job
```

Duty是Lord级别的"命令"，Job是Pawn级别的"执行"。一个Duty可能产生多个连续的Job。

---

## 第6章 派系与世界系统技术架构 ✅ [已有素材]

> **目标**：理解派系定义和世界地图的代码实现
> **对应模组需求**：BORDER派系、敌对惑星国家、门(Gate)袭击、远征船

### 6.1 派系系统 ✅

**概述**：派系由FactionDef定义静态属性，Faction类管理运行时状态。FactionManager统管所有派系实例。PawnGroupMaker控制袭击单位生成。

**已有素材**：
1. → `快速参考/原版派系类型总览.md` — FactionDef分类、techLevel
2. → `快速参考/派系Pawn特征与生成机制.md` — PawnGroupMaker、PawnGenOption
3. → `快速参考/派系关系与好感度系统.md` — FactionRelation、好感度变化
4. → `快速参考/敌对派系与玩家Pawn系统差异.md` — 敌对Pawn配置差异
5. → `快速参考/模组自定义派系与扩展模式.md` — 自定义FactionDef流程

### 6.2 袭击与事件系统 ✅

**概述**：事件系统由StorytellerComp调度，通过IncidentDef→IncidentWorker执行。袭击是最复杂的事件类型，涉及RaidStrategyDef和PawnsArrivalModeDef。

**已有素材**：
1. → `快速参考/事件系统大类与触发架构.md` — 事件分类、触发架构
2. → `快速参考/事件触发机制与叙事者系统.md` — StorytellerComp、事件调度
3. → `快速参考/派系与袭击关系.md` — 派系与袭击的关联
4. → `快速参考/袭击策略与到达模式.md` — RaidStrategyDef、PawnsArrivalModeDef
5. → `快速参考/袭击流程与结束条件.md` — 袭击完整流程、Lord状态机

### 6.3 世界地图系统 ✅

**概述**：世界地图对象由WorldObjectDef定义，WorldObject类管理运行时。远行队(Caravan)和穿梭机(TransportShip/CompShuttle)是两种主要的跨地图移动方式。

**已有素材**：
1. → `快速参考/世界地图可交互地点.md` — WorldObject体系
2. → `快速参考/远行队系统基本流程.md` — Caravan技术实现
3. → `快速参考/穿梭机系统与TransportShip架构.md` — TransportShip/CompShuttle
4. → `快速参考/传送类效果完整分类.md` — 传送效果技术实现

---

## 第7章 渲染与UI系统技术架构 ✅ [已整理]

> **目标**：理解视觉表现和用户界面的代码实现
> **对应模组需求**：战斗体视觉切换、Trion表现特效、Gizmo按钮

### 7.1 Pawn渲染管线 ✅

**概述**：Pawn渲染由PawnRenderTree管理，采用树形节点架构。静态节点由PawnRenderTreeDef定义，动态节点由5种DynamicPawnRenderNodeSetup在运行时注入。

**已有素材**：
1. → `快速参考/Pawn外观组成与渲染树系统.md` — PawnRenderTree完整结构、PawnRenderNode子类
2. → `快速参考/Pawn外观动态变化机制.md` — SetAllGraphicsDirty、动态切换
3. → `快速参考/Pawn形态与状态切换先例.md` — 原版形态切换案例
4. → `快速参考/模组改变Pawn外观实例.md` — 模组外观修改方案

### 7.2 特效系统 ✅ 已整理

RimWorld有两套粒子系统和一套效果器系统：

#### Mote vs Fleck

| 维度 | Mote | Fleck |
|------|------|-------|
| 本质 | Thing子类，存在于地图上 | 轻量数据结构，由FleckManager管理 |
| 性能 | 较重（参与Thing系统） | 较轻（无Thing开销） |
| 功能 | 可附着目标、可交互 | 纯视觉，无交互 |
| 创建 | `MoteMaker.MakeStaticMote()` 等 | `FleckMaker.Static()` / `FleckMaker.ThrowMetaIcon()` 等 |
| 适用 | 需要附着或持续跟踪的效果 | 简单的一次性视觉效果 |

**Mote继承链**：`Mote → Thing → Entity`
- 核心字段：`exactPosition`、`exactRotation`、`instanceColor`、`link1`（附着链接）
- 生命周期：`SpawnSetup()` → `Tick()`/`RealtimeUpdate()` → 超时自动销毁
- 维持机制：`Maintain()` 方法重置销毁计时器，用于持续效果

**Fleck**：由`FleckManager`统一管理，通过`FleckDef`定义外观参数，`FleckCreationData`传递创建参数。

#### Effecter效果器

`Effecter`是高层效果编排器，组合多个`SubEffecter`（子效果器）来实现复杂视觉效果。

```
EffecterDef（XML定义）
├── children: List<SubEffecterDef>
│   ├── SubEffecterDef_1 → 创建 SubEffecter_1（如生成Mote）
│   ├── SubEffecterDef_2 → 创建 SubEffecter_2（如播放声音）
│   └── ...
└── Effecter（运行时实例）
    ├── EffectTick(A, B) — 持续效果每Tick调用
    └── Trigger(A, B) — 一次性触发
```

**使用方式**：
- 持续效果：`effecter = def.Spawn()` → 每Tick调用 `effecter.EffectTick(A, B)` → `effecter.Cleanup()`
- 一次性效果：`def.Spawn().Trigger(A, B)`

### 7.3 Gizmo与UI ⚠️ → ✅ 已整理

**概述**：Gizmo是游戏内命令按钮的基类，通过GetGizmos()注入。Command_Action/Command_Toggle/Command_Target是最常用的子类。

**已有素材**：
1. → `快速参考/Gizmo命令按钮系统.md` — Gizmo继承树、GetGizmos()注入点

**补充：ITab检查面板**

ITab（InspectTabBase子类）是选中物体后底部面板的标签页。自定义ITab流程：
1. 继承 `ITab` 基类
2. 重写 `FillTab()` 绘制UI内容
3. 在ThingDef的 `inspectorTabs` 列表中注册

### 7.4 Skyfaller系统 ✅ 已整理

**概述**：Skyfaller是从天空降落或飞向天空的物体（如投放舱、穿梭机着陆、陨石等）。

**继承链**：`Skyfaller → ThingWithComps → Thing → Entity`

#### 核心字段

| 字段 | 类型 | 职责 |
|------|------|------|
| `innerContainer` | ThingOwner | 内部容器（携带的物品/Pawn） |
| `ticksToImpact` | int | 距离着陆的剩余Tick |
| `angle` | float | 飞行角度 |
| `ageTicks` | int | 已存在Tick数 |

#### 生命周期

1. **生成**：`SkyfallerMaker.SpawnSkyfaller()` 在地图上创建Skyfaller
2. **飞行**：每Tick更新位置（`ticksToImpact`递减），绘制飞行动画和阴影
3. **着陆**：`ticksToImpact == 0` 时调用 `Impact()` → `SpawnThings()` 释放内容物
4. **离开**（起飞型）：`LeaveMap()` 从地图移除

#### SkyfallerDef关键字段

通过ThingDef的`skyfaller`字段（SkyfallerProperties）配置：
- `movementType`：Accelerate（加速降落）/ Decelerate（减速降落）/ ConstantSpeed
- `speed`：飞行速度
- `impactSound`：着陆音效
- `shadow`/`shadowSize`：阴影配置

#### 与TransportShip的协作

穿梭机着陆流程：`CompShuttle`控制逻辑 → 创建Skyfaller（着陆动画）→ Impact时生成实际TransportShip建筑

**参考素材**：
- → `快速参考/穿梭机系统与TransportShip架构.md`（完整穿梭机流程）

---

## 第8章 数据持久化与存档系统 ✅ [已完成]

> **目标**：理解游戏存档的技术实现
> **对应模组需求**：所有自定义数据的保存/加载

### 8.1 ExposeData机制 ✅

**核心接口**：`Verse.IExposable`，仅定义一个方法 `void ExposeData()`。所有需要存档的对象都实现此接口。

**核心类**：`Verse.Scribe`，持有 `ScribeSaver`（保存器）和 `ScribeLoader`（加载器），通过静态字段 `Scribe.mode`（`LoadSaveMode`枚举）控制当前操作模式。

#### LoadSaveMode：五阶段生命周期

| 模式 | 触发时机 | 说明 |
|------|---------|------|
| `Inactive` | 默认状态 | 未进行存档操作 |
| `Saving` | 保存时 | 将数据写入XML |
| `LoadingVars` | 加载时（第一阶段） | 从XML读取基本值和ID字符串 |
| `ResolvingCrossRefs` | 加载时（第二阶段） | 将ID字符串解析为实际对象引用 |
| `PostLoadInit` | 加载时（第三阶段） | 所有数据就绪后的后处理 |

**关键理解**：`ExposeData()`在保存和加载时**都会被调用**，通过`Scribe.mode`区分当前操作。同一个方法同时处理保存和加载。

#### Scribe系列方法：六种数据类型对应六个Scribe类

| Scribe类 | 适用类型 | LookMode | 存档格式 |
|----------|---------|----------|---------|
| `Scribe_Values` | 基本类型（int/float/bool/string/enum/Vector等） | Value | 直接写入值文本 |
| `Scribe_Defs` | Def引用（ThingDef/HediffDef等） | Def | 写入defName字符串 |
| `Scribe_References` | 运行时对象引用（Thing/Pawn/Faction等ILoadReferenceable） | Reference | 写入UniqueLoadID |
| `Scribe_Deep` | 嵌套IExposable对象（需要深度序列化的复合对象） | Deep | 递归调用ExposeData() |
| `Scribe_Collections` | 列表/字典（List\<T\>/Dictionary\<K,V\>） | 按元素类型 | 容器+递归 |
| `Scribe_TargetInfo` | LocalTargetInfo/TargetInfo/GlobalTargetInfo | — | 专用格式 |

#### LookMode枚举

| 值 | 用途 | 说明 |
|----|------|------|
| `Value` | 基本值类型 | 直接序列化为字符串 |
| `Deep` | IExposable对象 | 递归调用ExposeData() |
| `Reference` | ILoadReferenceable对象 | 保存ID，加载时解析引用 |
| `Def` | Def引用 | 保存defName |
| `LocalTargetInfo` | 本地目标 | Thing引用或IntVec3 |
| `TargetInfo` | 目标信息 | 含Map引用 |
| `GlobalTargetInfo` | 全局目标 | 含World引用 |
| `BodyPart` | 身体部位 | 特殊处理 |

#### 调用模式与关键规则

**所有Scribe方法使用`ref`参数**——保存时读取值，加载时写入值：

```csharp
public override void PostExposeData()
{
    base.PostExposeData();
    // 基本值：Scribe_Values.Look(ref 字段, "标签", 默认值)
    Scribe_Values.Look(ref energy, "energy", 0f);
    Scribe_Values.Look(ref ticksToReset, "ticksToReset", -1);

    // Def引用：Scribe_Defs.Look(ref 字段, "标签")
    Scribe_Defs.Look(ref myDef, "myDef");

    // 对象引用：Scribe_References.Look(ref 字段, "标签")
    Scribe_References.Look(ref targetPawn, "targetPawn");

    // 深度嵌套：Scribe_Deep.Look(ref 字段, "标签", 构造参数...)
    Scribe_Deep.Look(ref hediffSet, "hediffSet", pawn);

    // 集合：Scribe_Collections.Look(ref 字段, "标签", LookMode)
    Scribe_Collections.Look(ref abilities, "abilities", LookMode.Deep, pawn);

    // PostLoadInit阶段的后处理
    if (Scribe.mode == LoadSaveMode.PostLoadInit)
    {
        // 此时所有数据已加载完毕，可做修正/清理
        abilities.RemoveAll(a => a.def == null);
    }
}
```

#### Scribe_Values关键行为

- **默认值优化**：值等于defaultValue时**不写入XML**（节省空间），加载时找不到节点则返回defaultValue
- **forceSave参数**：设为true时即使等于默认值也强制写入
- **类型安全检查**（Saving时）：
  - Thing类型 → 报错，应用Scribe_References或Scribe_Deep
  - IExposable类型 → 报错，应用Scribe_References或Scribe_Deep
  - Def类型 → 报错，应用Scribe_Defs
  - TargetInfo → 报错，应用Scribe_TargetInfo

#### Scribe_References与ILoadReferenceable

`Scribe_References`要求目标实现`ILoadReferenceable`接口（提供`GetUniqueLoadID()`方法）。

**三阶段处理**：
1. **Saving**：写入`refee.GetUniqueLoadID()`字符串
2. **LoadingVars**：读取ID字符串，注册到CrossRefResolver
3. **ResolvingCrossRefs**：通过ID查找实际对象，赋值给ref参数

**已销毁对象处理**：默认不保存已销毁Thing的引用（写入"null"），`saveDestroyedThings=true`可覆盖此行为。

#### Scribe_Deep深度序列化

- 保存时：进入XML子节点 → 调用`target.ExposeData()` → 退出节点
- 加载时：从XML子节点反序列化创建新对象（通过`ScribeExtractor.SaveableFromNode<T>()`）
- **多态支持**：如果运行时类型≠声明类型，自动写入`Class`属性
- **构造参数**：`ctorArgs`传递给对象构造函数（如Tracker需要owner Pawn引用）

#### Scribe_Collections集合序列化

```csharp
// 值类型列表
Scribe_Collections.Look(ref myInts, "myInts", LookMode.Value);

// Def引用列表
Scribe_Collections.Look(ref myDefs, "myDefs", LookMode.Def);

// 对象引用列表
Scribe_Collections.Look(ref myThings, "myThings", LookMode.Reference);

// 深度序列化列表（带构造参数）
Scribe_Collections.Look(ref myComps, "myComps", LookMode.Deep, pawn);

// 字典
Scribe_Collections.Look(ref myDict, "myDict", LookMode.Reference, LookMode.Value);
```

#### 常见陷阱与最佳实践

| 陷阱 | 说明 | 解决方案 |
|------|------|---------|
| 用错Scribe类 | Scribe_Values保存Thing引用 | 运行时报错提示，按提示切换 |
| 忘记调用base | ThingComp的PostExposeData不调base | 始终调用`base.PostExposeData()` |
| 默认值不匹配 | 保存时默认值=0跳过写入，加载时默认值=-1 | 保存和加载使用相同默认值 |
| null集合 | 加载后List为null而非空列表 | PostLoadInit中检查并初始化 |
| 引用解析时序 | LoadingVars阶段访问Reference字段（仍为null） | 在ResolvingCrossRefs或PostLoadInit阶段访问 |
| 新增字段无默认值 | 旧存档无该字段，加载后为default(T) | 提供合理的defaultValue参数 |

**详细素材**：
- → `快速参考/存档系统与ExposeData机制.md`（完整Scribe API、存档XML格式、复杂场景示例）

### 8.2 存档兼容性 ✅

**核心类**：`Verse.BackCompatibility`，集中管理跨版本存档兼容逻辑。

#### 新增字段的兼容

**最简单的情况**——Scribe_Values的defaultValue机制天然支持：

```csharp
// 新增字段，旧存档中不存在此节点
// 加载时自动使用defaultValue，无需额外处理
Scribe_Values.Look(ref newField, "newField", defaultValue: 10f);
```

**复杂情况**——需要在PostLoadInit中修正：

```csharp
if (Scribe.mode == LoadSaveMode.PostLoadInit)
{
    // 旧存档迁移：如果某字段需要根据其他已加载数据计算
    if (newField == default)
    {
        newField = CalculateFromExistingData();
    }
}
```

#### 移除字段的处理

- **XML中多余的节点会被静默忽略**——RimWorld的反序列化不会因为存档中有未知字段而报错
- 因此移除C#字段后，旧存档中的对应数据自动被忽略，无需特殊处理

#### BackCompatibility类的作用

`BackCompatibility`提供版本间的转换钩子：

| 方法 | 用途 |
|------|------|
| `IsSaveCompatibleWith(version)` | 检查存档版本是否兼容 |
| `PreLoadSavegame(version)` | 加载前的全局预处理 |
| `PostLoadSavegame(version)` | 加载后的全局后处理 |
| `BackCompatibleDefName(type, name)` | Def重命名映射（旧defName→新defName） |
| `GetBackCompatibleType(base, className)` | 类型重命名映射（旧类名→新类名） |
| `PostExposeData(obj)` | 对象级别的存档迁移钩子 |
| `WasDefRemoved(defName, type)` | 检查Def是否已被移除 |

#### 模组存档兼容策略

| 场景 | 推荐做法 |
|------|---------|
| 新增字段 | Scribe_Values提供合理defaultValue |
| 移除字段 | 直接删除，旧数据自动忽略 |
| 重命名字段 | 保留旧label读取 + 新label写入（过渡期） |
| Def重命名 | 使用XPath Patch或BackCompatibilityConverter |
| 类型变更 | PostLoadInit中做数据迁移 |
| 新增Comp | 旧存档Thing无此Comp数据，PostExposeData中处理默认状态 |

**核心原则**：RimWorld的存档系统对缺失数据非常宽容（静默使用默认值），对多余数据也宽容（静默忽略）。大多数情况下无需特殊兼容代码。

---

## 第9章 Harmony补丁系统 ✅ [已完成]

> **目标**：理解模组修改原版行为的核心技术
> **对应模组需求**：伤害拦截、状态切换、渲染修改等需要Hook原版代码的场景

### 9.1 Harmony基础 ✅

**核心库**：HarmonyX（HarmonyLib命名空间），RimWorld内置的运行时方法补丁框架。允许模组在不修改原版DLL的情况下，在任意方法的执行前/后/中注入自定义逻辑。

#### 初始化方式

**方式1：Mod构造函数中PatchAll**（最常用）

```csharp
public class MyMod : Mod
{
    public MyMod(ModContentPack content) : base(content)
    {
        var harmony = new Harmony("com.myname.mymod");
        harmony.PatchAll();  // 自动扫描当前程序集中所有[HarmonyPatch]标记的类
    }
}
```

**方式2：[StaticConstructorOnStartup]中初始化**（需要Def数据时）

```csharp
[StaticConstructorOnStartup]
public static class MyPatches
{
    static MyPatches()
    {
        var harmony = new Harmony("com.myname.mymod");
        harmony.PatchAll();
    }
}
```

**方式3：手动指定补丁类**（精确控制）

```csharp
harmony.CreateClassProcessor(typeof(MyPatchClass)).Patch();
```

**Harmony ID约定**：使用反向域名格式（如`com.author.modname`），用于标识补丁来源和卸载。

#### 三种补丁类型

| 类型 | 执行时机 | 能力 | 复杂度 |
|------|---------|------|--------|
| **Prefix** | 原方法执行**前** | 修改参数、跳过原方法、保存状态 | ★ |
| **Postfix** | 原方法执行**后** | 修改返回值、读取结果、后处理 | ★ |
| **Transpiler** | 编译时修改IL | 精确修改方法内部任意位置的逻辑 | ★★★★ |

#### [HarmonyPatch]特性标注

```csharp
// 类级标注（最常用）
[HarmonyPatch(typeof(Pawn), "Kill")]
public static class Pawn_Kill_Patch
{
    // Prefix/Postfix/Transpiler方法...
}

// 也可标注方法重载
[HarmonyPatch(typeof(DamageWorker), "Apply", typeof(DamageInfo), typeof(Thing))]
public static class DamageWorker_Apply_Patch { ... }

// 属性getter/setter
[HarmonyPatch(typeof(Pawn), nameof(Pawn.IsColonist), MethodType.Getter)]
public static class Pawn_IsColonist_Patch { ... }
```

#### 特殊参数约定（双下划线前缀）

| 参数名 | 类型 | 可用于 | 说明 |
|--------|------|--------|------|
| `__instance` | 目标类类型 | Prefix/Postfix | 实例方法的this引用 |
| `__result` | 返回值类型 | Prefix(ref)/Postfix(ref) | 方法返回值 |
| `__state` | 任意类型 | Prefix(out)→Postfix(in) | Prefix到Postfix的状态传递 |
| `___fieldName` | 字段类型 | Prefix/Postfix | 访问私有字段（三下划线+字段名） |
| 原参数名 | 原参数类型 | Prefix/Postfix | 与原方法参数同名即可注入 |

#### Priority优先级系统

多个模组补丁同一方法时，通过Priority控制执行顺序：

| 常量 | 值 | 说明 |
|------|---|------|
| `Priority.First` | 800 | 最先执行 |
| `Priority.VeryHigh` | 700 | — |
| `Priority.High` | 600 | — |
| `Priority.HigherThanNormal` | 500 | — |
| `Priority.Normal` | 400 | 默认值 |
| `Priority.LowerThanNormal` | 300 | — |
| `Priority.Low` | 200 | — |
| `Priority.VeryLow` | 100 | — |
| `Priority.Last` | 0 | 最后执行 |

**Prefix执行顺序**：Priority高→低（First先执行）
**Postfix执行顺序**：Priority低→高（Last先执行，First最后执行）

```csharp
[HarmonyPatch(typeof(Pawn), "Kill")]
public static class MyPatch
{
    [HarmonyPrefix]
    [HarmonyPriority(Priority.High)]  // 比其他模组的Prefix更早执行
    public static bool Prefix(Pawn __instance) { ... }
}
```

**详细素材**：
- → `快速参考/Harmony补丁系统与模式.md`（完整API、实战模式、冲突处理）

### 9.2 常用补丁模式 ✅

#### 模式1：条件拦截（Prefix返回false）

Prefix返回`false`时**跳过原方法**（和所有后续Prefix），直接执行Postfix。

```csharp
[HarmonyPatch(typeof(Pawn_HealthTracker), "MakeDowned")]
public static class PreventDowned_Patch
{
    public static bool Prefix(Pawn ___pawn)
    {
        // 条件：特定Hediff的Pawn不会倒地
        if (___pawn.health.hediffSet.HasHediff(MyHediffDefOf.Invincible))
        {
            return false;  // 跳过原方法
        }
        return true;  // 正常执行
    }
}
```

**注意**：返回false是侵入性最强的操作，容易与其他模组冲突。尽量避免。

#### 模式2：结果修改（Postfix修改__result）

```csharp
[HarmonyPatch(typeof(StatWorker), "GetValueUnfinalized")]
public static class ModifyStat_Patch
{
    public static void Postfix(ref float __result, StatRequest req, StatDef ___stat)
    {
        if (___stat == StatDefOf.MoveSpeed && req.Thing is Pawn pawn)
        {
            // 有特定Hediff时移速+50%
            if (pawn.health.hediffSet.HasHediff(MyHediffDefOf.SpeedBoost))
            {
                __result *= 1.5f;
            }
        }
    }
}
```

#### 模式3：状态传递（Prefix→Postfix via __state）

```csharp
[HarmonyPatch(typeof(Pawn), "Kill")]
public static class DeathEffect_Patch
{
    // Prefix保存死亡前的状态
    public static void Prefix(Pawn __instance, out Map __state)
    {
        __state = __instance.MapHeld;  // 死亡后MapHeld可能为null
    }

    // Postfix使用保存的状态
    public static void Postfix(Pawn __instance, Map __state)
    {
        if (__instance.Dead && __state != null)
        {
            // 使用死亡前保存的Map引用
            DoDeathEffect(__instance, __state);
        }
    }
}
```

#### 模式4：Transpiler（IL指令修改）

Transpiler直接操作方法的IL指令流，是最强大但也最脆弱的补丁方式。

```csharp
[HarmonyPatch(typeof(Projectile), "ImpactSomething")]
public static class Projectile_Dodge_Patch
{
    [HarmonyTranspiler]
    public static IEnumerable<CodeInstruction> Transpiler(
        IEnumerable<CodeInstruction> instructions, ILGenerator ilg)
    {
        var codes = instructions.ToList();
        var myMethod = AccessTools.Method(typeof(Projectile_Dodge_Patch), "CheckDodge");

        for (int i = 0; i < codes.Count; i++)
        {
            // 在特定位置注入调用
            if (codes[i].opcode == OpCodes.Stloc_2
                && codes[i-1].OperandIs(typeof(Pawn)))
            {
                yield return codes[i];
                yield return new CodeInstruction(OpCodes.Ldloc_2);
                yield return new CodeInstruction(OpCodes.Call, myMethod);
                continue;
            }
            yield return codes[i];
        }
    }
}
```

**Transpiler注意事项**：
- 依赖IL指令的精确位置，游戏版本更新后最容易失效
- 调试困难，需要IL知识
- 与其他Transpiler补丁容易冲突
- 仅在Prefix/Postfix无法实现时使用

### 9.3 补丁 vs Comp/Worker的选择 ✅

#### 决策树

```
需要修改原版行为？
├── 能通过XML配置实现？
│   └── ✅ 用XML（Def/Comp配置/XPath Patch）
├── 能通过Comp/Worker/DefModExtension实现？
│   └── ✅ 用数据驱动方案
├── 能通过Postfix实现？
│   └── ✅ 用Postfix（最安全的Harmony方式）
├── 必须拦截/跳过原方法？
│   └── ⚠️ 用Prefix（注意冲突风险）
└── 必须修改方法内部逻辑？
    └── ⚠️ 用Transpiler（最后手段）
```

#### 对比表

| 维度 | Comp/Worker/Extension | Harmony Postfix | Harmony Prefix | Harmony Transpiler |
|------|----------------------|-----------------|----------------|-------------------|
| **侵入性** | 无 | 低 | 中-高 | 高 |
| **冲突风险** | 极低 | 低 | 中 | 高 |
| **版本兼容** | 好 | 较好 | 一般 | 差 |
| **可维护性** | 好 | 好 | 一般 | 差 |
| **能力范围** | 仅扩展点 | 修改返回值/后处理 | 拦截/修改参数 | 任意修改 |
| **XML可配置** | ✅ | ❌ | ❌ | ❌ |

#### 实际场景选择指南

| 需求 | 推荐方案 | 原因 |
|------|---------|------|
| 给Pawn添加新能力 | AbilityDef + CompAbilityEffect | 数据驱动，无冲突 |
| 给物品添加新属性 | ThingComp | 标准扩展点 |
| 修改伤害计算 | StatWorker子类 或 Postfix | 优先用Worker |
| 阻止特定Pawn倒地 | Prefix（无替代方案） | 需要拦截原方法 |
| 修改渲染逻辑 | CompRenderNodes 或 Postfix | 优先用Comp |
| 给原版Def添加数据 | DefModExtension + XPath | 无需C#补丁 |
| 修改AI决策 | 自定义ThinkNode/JobGiver | 数据驱动 |
| 修改方法内部某一行 | Transpiler（最后手段） | 无其他方式 |

**核心原则**：Harmony是"最后手段"，不是"首选方案"。每个Harmony补丁都是对原版代码的硬依赖，增加维护成本和冲突风险。优先使用RimWorld提供的数据驱动扩展点（Comp/Worker/DefModExtension/ThinkNode等）。

---

## 第10章 模组基础设施 ❌ [待新建]

> **目标**：理解模组项目的基本结构和工具链

### 10.1 模组目录结构 ❌

**待研究要点**：
- About/（模组元信息）
- Defs/（XML定义文件）
- Assemblies/（编译后DLL）
- Patches/（XPath补丁）
- Textures/、Sounds/（资源文件）
- Languages/（本地化）
- 1.5/目录（版本适配）

### 10.2 XPath补丁系统 ❌

**待研究要点**：
- PatchOperationAdd/Remove/Replace/AddModExtension等
- 条件补丁（PatchOperationFindMod/PatchOperationConditional）
- 用途：修改原版或其他模组的Def

### 10.3 多版本与DLC兼容 ❌

**待研究要点**：
- 版本目录隔离
- ModsConfig.IsActive检查
- 条件编译与运行时检测

---

## 附录A 关键类速查表 ❌ [待新建]

> 按功能分类的核心C#类索引，待所有章节完成后汇总

## 附录B 2.6实体→技术框架映射 ❌ [待新建]

> 15个游戏实体各自涉及的Def类型、Comp类型、关键C#类，待所有章节完成后汇总

**部分素材**：
- → `快速参考/模组扩展战斗系统实例.md`（战斗相关实体映射参考）

---

## 大纲外现有文件归属建议

以下快速参考文件未被大纲直接覆盖，建议处理方式：

| 文件 | 建议 |
|------|------|
| `工作台基本工作流程.md` | 保留在快速参考，附录B中索引 |
| `配方系统与RecipeDef体系.md` | 保留在快速参考，附录B中索引 |
| `建筑供电系统.md` | 3.1 ThingComp素材 + 保留 |
| `科研系统架构与研究流程.md` | 保留在快速参考，附录B中索引 |
| `科研解锁机制与模组扩展.md` | 保留在快速参考，附录B中索引 |
| `模组自定义工作台与特殊功能.md` | 保留在快速参考，附录B中索引 |
| `模组自定义机械体与人工单位.md` | 保留在快速参考，附录B中索引 |
| `原版机械族单位总览.md` | 保留在快速参考，附录B中索引 |
| `物品分类与堆叠系统.md` | 2.3 ThingDef素材 + 保留 |

---

## 历史修改记录

| 版本 | 日期 | 修改摘要 | 签名 |
|------|------|---------|------|
| v0.1 | 2026-02-16 | 创建骨架文档，完成大纲结构搭建，标注各章节素材状态和引用 | Claude Opus 4.6 |
| v0.5 | 2026-02-16 | 完成第3-7章实际内容整合：Comp系统(3章)、Pawn类结构(4.1)、Lord/Duty系统(5.2-5.3)、特效系统(7.2)、Skyfaller(7.4)；第1/2/8/9/10章保持待填状态 | Claude Opus 4.6 |
| v0.6 | 2026-02-16 | 完成第1章全部4节：程序集结构(1.1)、启动加载流程(1.2)、Tick系统(1.3)、核心设计模式(1.4)。基于PlayDataLoader/TickManager/TickList源码研究 | Claude Opus 4.6 |
| v0.7 | 2026-02-16 | 完成第2章全部5节：Def体系总览(2.1)、XML配置系统(2.2)、ThingDef详解(2.3)、DefModExtension扩展机制(2.4)、Def交叉引用与依赖(2.5)。基于Def/DefDatabase/DirectXmlToObject/XmlInheritance/DirectXmlCrossRefLoader/DefOfHelper源码研究 | Claude Opus 4.6 |
| v0.9 | 2026-02-16 | 完成第8章全部2节：ExposeData机制(8.1)、存档兼容性(8.2)。完成第9章全部3节：Harmony基础(9.1)、常用补丁模式(9.2)、补丁vs数据驱动选择(9.3)。基于Scribe系列/IExposable/LoadSaveMode/BackCompatibility源码和HarmonyX/社区模组实例研究。新增快速参考：存档系统与ExposeData机制.md、Harmony补丁系统与模式.md | Claude Opus 4.6 |
