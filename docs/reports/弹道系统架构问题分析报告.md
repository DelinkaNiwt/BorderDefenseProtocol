---
标题：BDP弹道系统架构问题分析报告
版本号: v1.0
更新日期: 2026-02-28 14:30:00
最后修改者: Claude Opus 4.6
标签：[文档][用户未确认][已完成][未锁定]
摘要: 对BDP模组追踪模块(TrackingModule)和引导模块(GuidedModule)的架构问题进行系统性诊断。基于Claude Opus 4.6与GPT-5.2两份独立分析的交叉验证，识别职责越界、契约违反、补丁连锁等核心问题。
---

## 一、分析背景

### 1.1 问题现象

BDP弹道系统在调试追踪和引导两个模块时，持续出现"修一个bug引发其它bug"的连锁反应。具体表现为命中判定异常、子弹穿墙、路径碰撞判定不稳定等问题反复交替出现。

### 1.2 用户预期的架构原则

> 追踪模块和引导模块的核心任务就1件事：**告诉子弹我接下来该往哪飞**。
> 其它的和该核心任务无关的东西那都该是子弹自己或者其它模块的事。

- 引导模块：开枪前预设中转点，子弹依次直飞各中转点，最后直飞目标。中没中不关它的事。
- 追踪模块：子弹飞出后，按规则每tick告诉子弹往哪个方向偏一点。追不追得上、中没中也不关它的事。

### 1.3 分析方法

由Claude Opus 4.6和GPT-5.2分别独立阅读全部相关源码后出具分析报告，再进行交叉验证和客观自审。

涉及的核心文件：

| 文件 | 职责 |
|------|------|
| `Bullet_BDP.cs` | 管线宿主，管线分发 |
| `TrackingModule.cs` | 追踪模块 |
| `GuidedModule.cs` | 引导模块 |
| `GuidedVerbState.cs` | Verb层引导状态管理 |
| `ObstacleRouter.cs` | 自动绕行路由 |
| `BDPTrackingConfig.cs` | 追踪配置 |
| `IBDPProjectileModule.cs` + Pipeline/*.cs | 管线接口定义 |

---

## 二、交叉验证结果

### 2.1 双方一致认定的问题（高置信度）

以下问题两份分析均独立识别并给出一致结论：

#### P1. 导航模块介入命中结果层

TrackingModule通过`forceUsedTargetOnFinalApproach`和`forceUsedTargetOnArrival`两个配置项，在极近距离和到达判定时直接将`host.usedTarget`同步为`TrackingTarget`。

```
TrackingModule.cs:201-202  — finalApproach时同步usedTarget
TrackingModule.cs:348-351  — HandleArrival时同步usedTarget
BDPTrackingConfig.cs:69-72 — 两个force配置项
```

同时，`Bullet_BDP.ImpactSomething`中增加了`TrackingExpired`补丁，追踪过期时强制`Impact(null)`打地面：

```
Bullet_BDP.cs:378-389 — TrackingExpired强制打地面
```

**违反原则**：追踪模块在替子弹决定"你该命中谁"和"你该不该命中"。

**根因**：vanilla的`usedTarget`机制会无视距离直接命中原始目标（`Projectile.cs:516: if(usedTarget.HasThing && CanHit) → Impact(usedTarget.Thing)`），追踪弹如果不干预就会出现"飞过目标后凭空命中"的幽灵伤害。

#### P2. 导航模块管理子弹生命周期

TrackingModule在`OnTick`中执行两种自毁逻辑：

```
TrackingModule.cs:264-272 — 超时自毁（flyingTicks >= maxFlyingTicks）
TrackingModule.cs:292-304 — 丢锁超时自毁（trackingLostTicks >= destroyAfter）
```

**违反原则**：子弹什么时候该销毁不是"告诉子弹往哪飞"的职责范围。

#### P3. origin后退hack与vanilla拦截系统的结构性冲突

`RedirectFlightTracking`和`RedirectFlightGuided`都使用`ORIGIN_OFFSET = 6f`将origin往后退6格：

```
Bullet_BDP.cs:135-138 — RedirectFlightGuided中的origin后退
Bullet_BDP.cs:171-173 — RedirectFlightTracking中的origin后退
```

**根因**：vanilla的`InterceptChanceFactorFromDistance(origin, cell)`在origin到拦截格距离²≤25时返回0（`Projectile.cs:303`）。每tick重定向导致origin贴近子弹当前位置，与前方墙壁距离永远只有1-2格，墙壁拦截完全失效。

**影响**：origin的语义从"子弹实际出发点"变为"为拦截公式服务的虚拟点"。虽然经验证ExactPosition插值数学仍然自洽（见自审§3.2），但增加了代码理解难度和维护风险。

#### P4. 引导与追踪通过宿主字段隐式耦合

两个模块通过`Bullet_BDP`上的`IsOnFinalSegment`字段协作：

```
GuidedModule.cs:84   — SetWaypoints时设false
GuidedModule.cs:50   — 最后一个锚点时设true
TrackingModule.cs:105 — 检查此字段，false时不激活
```

无接口约束，纯靠字段值和执行顺序（Priority 10 vs 15）保证正确性。

#### P5. 初始化时序问题导致多源真相

RimWorld生命周期为`Spawn → SpawnSetup → Launch`，SpawnSetup时`intendedTarget`尚未赋值（默认(0,0,0)），导致`FinalTarget`/`TrackingTarget`初始化为无效值：

```
Bullet_BDP.cs:290-305 — postLaunchInitDone补丁
GuidedModule.cs:80-83 — SetWaypoints中额外同步TrackingTarget
```

**影响**：每个新模块如果涉及目标引用，都必须知道这个时序陷阱并手动处理。

#### P6. 补丁连锁反应

两份分析均识别出相同的连锁模式：

```
每tick重定向 → origin贴近子弹 → 墙壁拦截失效（穿墙）
    ↓ 修复：origin后退6格
    ↓ 副作用：origin语义改变

usedTarget未同步 → 飞过目标后幽灵命中
    ↓ 修复：追踪模块强制同步usedTarget
    ↓ 副作用：导航层介入结果层
    ↓ 再修复：TrackingExpired强制打地面
    ↓ 副作用：近目标过期时本该命中也打地面

丢锁后子弹残留 → vanilla拦截概率触发 → 凭空受伤
    ↓ 修复：丢锁超时自毁
    ↓ 副作用：追踪模块管理生命周期
```

### 2.2 GPT-5.2独立发现、经验证确认的问题

#### P7. 管线契约违反：PathResolver越权修改宿主

`IBDPPathResolver`的契约是通过`ref PathContext ctx`修改`ctx.Destination`。但TrackingModule通过调用`host.RedirectFlightTracking()`直接修改了宿主的`origin`和`ticksToImpact`：

```
TrackingModule.cs:213 — ctx.Destination = host.RedirectFlightTracking(...)
Bullet_BDP.cs:162-200 — RedirectFlightTracking直接修改origin/ticksToImpact
```

PathResolver名义上只改Destination，实际上通过宿主方法绕开了契约，修改了origin和ticksToImpact。

**验证结论**：**确认属实**。这是一个真实的契约违反。

#### P8. 管线契约违反：TickObserver执行销毁

`IBDPTickObserver`从命名和文档定位是"只读观察者"（拖尾/视觉/音效），但TrackingModule在`OnTick`中调用`host.Destroy()`：

```
IBDPTickObserver.cs — 接口定义为观察者
TrackingModule.cs:269-270 — OnTick中销毁子弹
TrackingModule.cs:302-303 — OnTick中销毁子弹
```

**验证结论**：**确认属实**。观察者不应有副作用，更不应销毁被观察对象。

#### P9. XML配置与注释不一致

Argus（天眼）的XML注释写`trackingDelay=0`（因为追踪仅在IsOnFinalSegment=true时激活），但实际配置值为`3`：

```
ThingDefs_Projectiles.xml:154 — 注释：trackingDelay=0
ThingDefs_Projectiles.xml:185 — 实际：<trackingDelay>3</trackingDelay>
```

**验证结论**：**确认属实**。这会导致末段追踪额外延迟3tick。

### 2.3 Claude Opus 4.6独立发现的补充问题

#### P10. RedirectFlightTracking的三段式状态机

远距离（>3×speed）用固定60tick，近距离用实际距离+CeilToInt，极近距离（≤1.5×speed）触发`finalApproach`。三个阈值均为经验值：

```
Bullet_BDP.cs:176-198 — 三段式距离策略
TrackingModule.cs:198-211 — finalApproach触发
```

换一个弹速就可能需要重新调整阈值，脆弱性较高。

#### P11. GuidedVerbState职责过重

`GuidedVerbState`（293行）承担了锚点存储、LOS重定向、CastOn拦截（单侧/双侧各一套）、PostCastOn处理（单侧/双侧各一套）、自动绕行路由准备与分配等多项职责。每次Verb层变化都需要在此类中增加对应分支。

---

## 三、客观自审

### 3.1 Claude Opus 4.6自审

| 原始论断 | 自审结论 | 说明 |
|---------|---------|------|
| 追踪模块越权管理命中判定 | ✅ 准确 | 与GPT-5.2一致，代码证据充分 |
| 追踪模块越权管理生命周期 | ✅ 准确 | 与GPT-5.2一致 |
| origin后退hack改变origin语义 | ⚠️ 部分准确 | 语义确实改变，但我原文暗示"影响ExactPosition插值"——经数学验证，插值结果仍然自洽（见3.2），此处表述不够精确 |
| GuidedVerbState是过大的胶水层 | ✅ 准确 | 架构观察，非bug声明 |
| 三段式状态机脆弱 | ✅ 准确 | 经验值依赖弹速，无自适应机制 |
| **遗漏**：未识别PathResolver契约违反 | ❌ 遗漏 | GPT-5.2正确指出，TrackingModule通过宿主方法绕开了PathContext契约 |
| **遗漏**：未识别TickObserver契约违反 | ❌ 遗漏 | GPT-5.2正确指出，观察者接口中执行了销毁操作 |
| **遗漏**：未发现XML配置不一致 | ❌ 遗漏 | GPT-5.2正确指出Argus的trackingDelay注释与实际值不符 |

### 3.2 ExactPosition插值自洽性验证

origin后退6格后，ExactPosition在重定向瞬间是否仍等于子弹实际位置？

以远距离情况为例：
- `origin = newOrigin - dir × 6`
- `destination = newOrigin + dir × (60 × speed)`
- `ticksToImpact = 60`
- `StartingTicksToImpact = |dest - origin| / speed = (6 + 60×speed) / speed`
- `progress = 1 - 60 / ((6 + 60×speed) / speed) = 6 / (6 + 60×speed)`
- `ExactPosition = origin + (dest - origin) × progress`
- `= (newOrigin - dir×6) + dir×(6 + 60×speed) × 6/(6 + 60×speed)`
- `= newOrigin - dir×6 + dir×6 = newOrigin` ✅

**结论**：数学自洽，ExactPosition在重定向瞬间精确等于子弹实际位置。origin后退不影响位置插值的正确性，但改变了origin的语义含义。

### 3.3 GPT-5.2自审（由Opus代为评估）

| GPT-5.2论断 | 评估结论 | 说明 |
|------------|---------|------|
| 结果层泄漏进导航层 | ✅ 准确 | 与Opus一致 |
| 管线契约被绕开（PathResolver） | ✅ 准确 | Opus遗漏，经验证确认 |
| 管线契约被绕开（TickObserver） | ✅ 准确 | Opus遗漏，经验证确认 |
| 时序修补导致多源真相 | ✅ 准确 | 与Opus一致 |
| trackingDelay配置不一致 | ✅ 准确 | 经XML验证确认 |
| currentTarget锁Cell导致usedTarget丢失Thing | ✅ 准确 | `GuidedVerbState.PostCastOn`将currentTarget转为Cell，vanilla的`ImpactSomething`中usedTarget退化为概率命中分支 |

---

## 四、问题全景：职责越界总表

| 编号 | 越权职责 | 预期归属 | 实际所在 | 严重度 |
|------|---------|---------|---------|--------|
| P1 | 命中判定（usedTarget同步） | 子弹Impact层 | TrackingModule | 高 |
| P2 | 生命周期管理（自毁） | 子弹/生命周期模块 | TrackingModule.OnTick | 高 |
| P3 | vanilla拦截适配（origin后退） | 子弹/拦截适配层 | RedirectFlight系列方法 | 中 |
| P4 | 模块间协作协议 | 接口/事件机制 | 宿主bool字段隐式传递 | 中 |
| P5 | 目标初始化时序 | 统一初始化流程 | 多处分散补丁 | 中 |
| P7 | PathResolver越权修改宿主 | 仅修改ctx.Destination | 通过宿主方法改origin/TTI | 高 |
| P8 | TickObserver执行销毁 | 仅观察，不修改 | OnTick中Destroy | 高 |
| P9 | XML配置准确性 | 注释与值一致 | Argus trackingDelay不一致 | 低 |
| P10 | 距离策略硬编码 | 自适应或配置化 | 三段式经验值阈值 | 低 |
| P11 | GuidedVerbState职责过重 | 更薄的适配层 | 293行多职责类 | 中 |

---

## 五、补丁连锁反应图

```
┌─────────────────────────────────────────────────────────────┐
│                    根源：每tick重写弹道参数                    │
│         (origin / destination / ticksToImpact)               │
└──────────────┬──────────────────────┬────────────────────────┘
               │                      │
               ▼                      ▼
    ┌──────────────────┐    ┌─────────────────────┐
    │ origin贴近子弹    │    │ usedTarget语义漂移   │
    │ → 墙壁拦截失效    │    │ → 幽灵命中           │
    └────────┬─────────┘    └──────────┬──────────┘
             │                         │
             ▼                         ▼
    ┌──────────────────┐    ┌─────────────────────┐
    │ 补丁A:            │    │ 补丁B:               │
    │ origin后退6格     │    │ 追踪模块同步         │
    │                  │    │ usedTarget            │
    └────────┬─────────┘    └──────────┬──────────┘
             │                         │
             ▼                         ▼
    ┌──────────────────┐    ┌─────────────────────┐
    │ 副作用:           │    │ 副作用:              │
    │ origin语义改变    │    │ 导航层介入结果层     │
    │ 契约被绕开        │    │ 与掩体/姿态语义冲突  │
    └────────┬─────────┘    └──────────┬──────────┘
             │                         │
             ▼                         ▼
    ┌──────────────────┐    ┌─────────────────────┐
    │ 补丁A2:           │    │ 补丁B2:              │
    │ 三段式距离策略     │    │ TrackingExpired      │
    │ (远/近/极近)      │    │ 强制Impact(null)     │
    └──────────────────┘    └──────────┬──────────┘
                                       │
                                       ▼
                            ┌─────────────────────┐
                            │ 副作用:              │
                            │ 近目标过期时         │
                            │ 本该命中也打地面     │
                            └──────────┬──────────┘
                                       │
                                       ▼
                            ┌─────────────────────┐
                            │ 补丁B3:              │
                            │ 丢锁超时自毁         │
                            │ (TickObserver中)     │
                            └──────────┬──────────┘
                                       │
                                       ▼
                            ┌─────────────────────┐
                            │ 副作用:              │
                            │ 观察者契约被破坏     │
                            │ 追踪模块管理生命周期 │
                            └─────────────────────┘
```

---

## 六、核心结论

### 6.1 一句话总结

当前弹道系统不是"纯导航管线"，而是**"导航 + 结果补丁 + 时序补丁 + 拦截适配"的混合体**。管线架构v4的接口设计是好的，但实现层面的职责越界导致模块间形成了补丁依赖网，这就是"改一个问题其它问题又出现"的根本原因。

### 6.2 问题本质

追踪模块和引导模块被迫承担了不属于它们的职责，原因是vanilla的三个机制与"每tick重定向弹道"这一行为存在根本冲突：

1. **vanilla拦截机制**：依赖origin距离，每tick重定向使origin贴近子弹 → 拦截失效
2. **vanilla命中机制**：usedTarget无视距离直接命中 → 幽灵伤害
3. **vanilla生命周期**：SpawnSetup时目标未就绪 → 初始化时序错误

这三个冲突的修复代码被分散塞进了追踪模块、引导模块和宿主类中，而不是集中在一个"vanilla适配层"里处理。

### 6.3 用户预期与现状的差距

| 维度 | 用户预期 | 现状 |
|------|---------|------|
| 追踪模块职责 | 只管每tick往哪偏 | 还管命中、自毁、usedTarget |
| 引导模块职责 | 只管预设中转点 | 还管TrackingTarget同步、IsOnFinalSegment |
| 管线契约 | PathResolver只改Destination | 实际还改origin/ticksToImpact |
| 管线契约 | TickObserver只读观察 | 实际执行Destroy |
| 模块独立性 | 互不依赖 | 通过宿主字段隐式耦合 |

---

## 历史修改记录
（注：摘要描述遵循奥卡姆剃刀原则）
| 版本 | 日期 | 修改摘要 | 签名 |
|------|------|---------|------|
| v1.0 | 2026-02-28 14:30:00 | 初版：双AI交叉验证架构分析报告 | Claude Opus 4.6 |
